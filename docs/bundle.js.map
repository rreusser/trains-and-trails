{"version":3,"file":"bundle.js","sources":["../node_modules/preact/dist/preact.module.js","../node_modules/htm/dist/htm.module.js","../node_modules/htm/preact/index.module.js","../node_modules/preact/hooks/dist/hooks.module.js","../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/bbox/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/@turf/length/dist/es/index.js","../node_modules/@turf/bearing/dist/es/index.js","../node_modules/@turf/destination/dist/es/index.js","../lib/mapbox-gl-third-person-camera.js","../node_modules/@turf/clean-coords/dist/es/index.js","../node_modules/@turf/clone/dist/es/index.js","../node_modules/@turf/simplify/dist/es/index.js","../src/data/route.js","../node_modules/@turf/along/dist/es/index.js","../src/data/map-controller.js","../src/util/raf.js","../src/util/lerp.js","../src/util/smoother.js","../src/data/elevation-plot.js","../src/data/page-controller.js","../src/data/page-controller-context.js","../src/components/map.js","../src/components/article.js","../src/components/app.js","../src/index.js"],"sourcesContent":["var n,l,u,i,t,o,r,f,e={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function h(n){var l=n.parentNode;l&&l.removeChild(n)}function v(l,u,i){var t,o,r,f={};for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];if(arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),\"function\"==typeof l&&null!=l.defaultProps)for(r in l.defaultProps)void 0===f[r]&&(f[r]=l.defaultProps[r]);return y(l,f,t,o,null)}function y(n,i,t,o,r){var f={type:n,props:i,key:t,ref:o,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,__h:null,constructor:void 0,__v:null==r?++u:r};return null==r&&null!=l.vnode&&l.vnode(f),f}function p(){return{current:null}}function d(n){return n.children}function _(n,l){this.props=n,this.context=l}function k(n,l){if(null==l)return n.__?k(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return\"function\"==typeof n.type?k(n):null}function b(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return b(n)}}function m(n){(!n.__d&&(n.__d=!0)&&t.push(n)&&!g.__r++||r!==l.debounceRendering)&&((r=l.debounceRendering)||o)(g)}function g(){for(var n;g.__r=t.length;)n=t.sort(function(n,l){return n.__v.__b-l.__v.__b}),t=[],n.some(function(n){var l,u,i,t,o,r;n.__d&&(o=(t=(l=n).__v).__e,(r=l.__P)&&(u=[],(i=a({},t)).__v=t.__v+1,j(r,t,i,l.__n,void 0!==r.ownerSVGElement,null!=t.__h?[o]:null,u,null==o?k(t):o,t.__h),z(u,t),t.__e!=o&&b(t)))})}function w(n,l,u,i,t,o,r,f,s,a){var h,v,p,_,b,m,g,w=i&&i.__k||c,A=w.length;for(u.__k=[],h=0;h<l.length;h++)if(null!=(_=u.__k[h]=null==(_=l[h])||\"boolean\"==typeof _?null:\"string\"==typeof _||\"number\"==typeof _||\"bigint\"==typeof _?y(null,_,null,null,_):Array.isArray(_)?y(d,{children:_},null,null,null):_.__b>0?y(_.type,_.props,_.key,null,_.__v):_)){if(_.__=u,_.__b=u.__b+1,null===(p=w[h])||p&&_.key==p.key&&_.type===p.type)w[h]=void 0;else for(v=0;v<A;v++){if((p=w[v])&&_.key==p.key&&_.type===p.type){w[v]=void 0;break}p=null}j(n,_,p=p||e,t,o,r,f,s,a),b=_.__e,(v=_.ref)&&p.ref!=v&&(g||(g=[]),p.ref&&g.push(p.ref,null,_),g.push(v,_.__c||b,_)),null!=b?(null==m&&(m=b),\"function\"==typeof _.type&&_.__k===p.__k?_.__d=s=x(_,s,n):s=P(n,_,p,w,b,s),\"function\"==typeof u.type&&(u.__d=s)):s&&p.__e==s&&s.parentNode!=n&&(s=k(p))}for(u.__e=m,h=A;h--;)null!=w[h]&&(\"function\"==typeof u.type&&null!=w[h].__e&&w[h].__e==u.__d&&(u.__d=k(i,h+1)),N(w[h],w[h]));if(g)for(h=0;h<g.length;h++)M(g[h],g[++h],g[++h])}function x(n,l,u){for(var i,t=n.__k,o=0;t&&o<t.length;o++)(i=t[o])&&(i.__=n,l=\"function\"==typeof i.type?x(i,l,u):P(u,i,i,t,i.__e,l));return l}function A(n,l){return l=l||[],null==n||\"boolean\"==typeof n||(Array.isArray(n)?n.some(function(n){A(n,l)}):l.push(n)),l}function P(n,l,u,i,t,o){var r,f,e;if(void 0!==l.__d)r=l.__d,l.__d=void 0;else if(null==u||t!=o||null==t.parentNode)n:if(null==o||o.parentNode!==n)n.appendChild(t),r=null;else{for(f=o,e=0;(f=f.nextSibling)&&e<i.length;e+=2)if(f==t)break n;n.insertBefore(t,o),r=o}return void 0!==r?r:t.nextSibling}function C(n,l,u,i,t){var o;for(o in u)\"children\"===o||\"key\"===o||o in l||H(n,o,null,u[o],i);for(o in l)t&&\"function\"!=typeof l[o]||\"children\"===o||\"key\"===o||\"value\"===o||\"checked\"===o||u[o]===l[o]||H(n,o,l[o],u[o],i)}function $(n,l,u){\"-\"===l[0]?n.setProperty(l,u):n[l]=null==u?\"\":\"number\"!=typeof u||s.test(l)?u:u+\"px\"}function H(n,l,u,i,t){var o;n:if(\"style\"===l)if(\"string\"==typeof u)n.style.cssText=u;else{if(\"string\"==typeof i&&(n.style.cssText=i=\"\"),i)for(l in i)u&&l in u||$(n.style,l,\"\");if(u)for(l in u)i&&u[l]===i[l]||$(n.style,l,u[l])}else if(\"o\"===l[0]&&\"n\"===l[1])o=l!==(l=l.replace(/Capture$/,\"\")),l=l.toLowerCase()in n?l.toLowerCase().slice(2):l.slice(2),n.l||(n.l={}),n.l[l+o]=u,u?i||n.addEventListener(l,o?T:I,o):n.removeEventListener(l,o?T:I,o);else if(\"dangerouslySetInnerHTML\"!==l){if(t)l=l.replace(/xlink(H|:h)/,\"h\").replace(/sName$/,\"s\");else if(\"href\"!==l&&\"list\"!==l&&\"form\"!==l&&\"tabIndex\"!==l&&\"download\"!==l&&l in n)try{n[l]=null==u?\"\":u;break n}catch(n){}\"function\"==typeof u||(null!=u&&(!1!==u||\"a\"===l[0]&&\"r\"===l[1])?n.setAttribute(l,u):n.removeAttribute(l))}}function I(n){this.l[n.type+!1](l.event?l.event(n):n)}function T(n){this.l[n.type+!0](l.event?l.event(n):n)}function j(n,u,i,t,o,r,f,e,c){var s,h,v,y,p,k,b,m,g,x,A,P=u.type;if(void 0!==u.constructor)return null;null!=i.__h&&(c=i.__h,e=u.__e=i.__e,u.__h=null,r=[e]),(s=l.__b)&&s(u);try{n:if(\"function\"==typeof P){if(m=u.props,g=(s=P.contextType)&&t[s.__c],x=s?g?g.props.value:s.__:t,i.__c?b=(h=u.__c=i.__c).__=h.__E:(\"prototype\"in P&&P.prototype.render?u.__c=h=new P(m,x):(u.__c=h=new _(m,x),h.constructor=P,h.render=O),g&&g.sub(h),h.props=m,h.state||(h.state={}),h.context=x,h.__n=t,v=h.__d=!0,h.__h=[]),null==h.__s&&(h.__s=h.state),null!=P.getDerivedStateFromProps&&(h.__s==h.state&&(h.__s=a({},h.__s)),a(h.__s,P.getDerivedStateFromProps(m,h.__s))),y=h.props,p=h.state,v)null==P.getDerivedStateFromProps&&null!=h.componentWillMount&&h.componentWillMount(),null!=h.componentDidMount&&h.__h.push(h.componentDidMount);else{if(null==P.getDerivedStateFromProps&&m!==y&&null!=h.componentWillReceiveProps&&h.componentWillReceiveProps(m,x),!h.__e&&null!=h.shouldComponentUpdate&&!1===h.shouldComponentUpdate(m,h.__s,x)||u.__v===i.__v){h.props=m,h.state=h.__s,u.__v!==i.__v&&(h.__d=!1),h.__v=u,u.__e=i.__e,u.__k=i.__k,u.__k.forEach(function(n){n&&(n.__=u)}),h.__h.length&&f.push(h);break n}null!=h.componentWillUpdate&&h.componentWillUpdate(m,h.__s,x),null!=h.componentDidUpdate&&h.__h.push(function(){h.componentDidUpdate(y,p,k)})}h.context=x,h.props=m,h.state=h.__s,(s=l.__r)&&s(u),h.__d=!1,h.__v=u,h.__P=n,s=h.render(h.props,h.state,h.context),h.state=h.__s,null!=h.getChildContext&&(t=a(a({},t),h.getChildContext())),v||null==h.getSnapshotBeforeUpdate||(k=h.getSnapshotBeforeUpdate(y,p)),A=null!=s&&s.type===d&&null==s.key?s.props.children:s,w(n,Array.isArray(A)?A:[A],u,i,t,o,r,f,e,c),h.base=u.__e,u.__h=null,h.__h.length&&f.push(h),b&&(h.__E=h.__=null),h.__e=!1}else null==r&&u.__v===i.__v?(u.__k=i.__k,u.__e=i.__e):u.__e=L(i.__e,u,i,t,o,r,f,c);(s=l.diffed)&&s(u)}catch(n){u.__v=null,(c||null!=r)&&(u.__e=e,u.__h=!!c,r[r.indexOf(e)]=null),l.__e(n,u,i)}}function z(n,u){l.__c&&l.__c(u,n),n.some(function(u){try{n=u.__h,u.__h=[],n.some(function(n){n.call(u)})}catch(n){l.__e(n,u.__v)}})}function L(l,u,i,t,o,r,f,c){var s,a,v,y=i.props,p=u.props,d=u.type,_=0;if(\"svg\"===d&&(o=!0),null!=r)for(;_<r.length;_++)if((s=r[_])&&\"setAttribute\"in s==!!d&&(d?s.localName===d:3===s.nodeType)){l=s,r[_]=null;break}if(null==l){if(null===d)return document.createTextNode(p);l=o?document.createElementNS(\"http://www.w3.org/2000/svg\",d):document.createElement(d,p.is&&p),r=null,c=!1}if(null===d)y===p||c&&l.data===p||(l.data=p);else{if(r=r&&n.call(l.childNodes),a=(y=i.props||e).dangerouslySetInnerHTML,v=p.dangerouslySetInnerHTML,!c){if(null!=r)for(y={},_=0;_<l.attributes.length;_++)y[l.attributes[_].name]=l.attributes[_].value;(v||a)&&(v&&(a&&v.__html==a.__html||v.__html===l.innerHTML)||(l.innerHTML=v&&v.__html||\"\"))}if(C(l,p,y,o,c),v)u.__k=[];else if(_=u.props.children,w(l,Array.isArray(_)?_:[_],u,i,t,o&&\"foreignObject\"!==d,r,f,r?r[0]:i.__k&&k(i,0),c),null!=r)for(_=r.length;_--;)null!=r[_]&&h(r[_]);c||(\"value\"in p&&void 0!==(_=p.value)&&(_!==l.value||\"progress\"===d&&!_||\"option\"===d&&_!==y.value)&&H(l,\"value\",_,y.value,!1),\"checked\"in p&&void 0!==(_=p.checked)&&_!==l.checked&&H(l,\"checked\",_,y.checked,!1))}return l}function M(n,u,i){try{\"function\"==typeof n?n(u):n.current=u}catch(n){l.__e(n,i)}}function N(n,u,i){var t,o;if(l.unmount&&l.unmount(n),(t=n.ref)&&(t.current&&t.current!==n.__e||M(t,null,u)),null!=(t=n.__c)){if(t.componentWillUnmount)try{t.componentWillUnmount()}catch(n){l.__e(n,u)}t.base=t.__P=null}if(t=n.__k)for(o=0;o<t.length;o++)t[o]&&N(t[o],u,\"function\"!=typeof n.type);i||null==n.__e||h(n.__e),n.__e=n.__d=void 0}function O(n,l,u){return this.constructor(n,u)}function S(u,i,t){var o,r,f;l.__&&l.__(u,i),r=(o=\"function\"==typeof t)?null:t&&t.__k||i.__k,f=[],j(i,u=(!o&&t||i).__k=v(d,null,[u]),r||e,e,void 0!==i.ownerSVGElement,!o&&t?[t]:r?null:i.firstChild?n.call(i.childNodes):null,f,!o&&t?t:r?r.__e:i.firstChild,o),z(f,u)}function q(n,l){S(n,l,q)}function B(l,u,i){var t,o,r,f=a({},l.props);for(r in u)\"key\"==r?t=u[r]:\"ref\"==r?o=u[r]:f[r]=u[r];return arguments.length>2&&(f.children=arguments.length>3?n.call(arguments,2):i),y(l.type,f,t||l.key,o||l.ref,null)}function D(n,l){var u={__c:l=\"__cC\"+f++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var u,i;return this.getChildContext||(u=[],(i={})[l]=this,this.getChildContext=function(){return i},this.shouldComponentUpdate=function(n){this.props.value!==n.value&&u.some(m)},this.sub=function(n){u.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){u.splice(u.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Provider.__=u.Consumer.contextType=u}n=c.slice,l={__e:function(n,l,u,i){for(var t,o,r;l=l.__;)if((t=l.__c)&&!t.__)try{if((o=t.constructor)&&null!=o.getDerivedStateFromError&&(t.setState(o.getDerivedStateFromError(n)),r=t.__d),null!=t.componentDidCatch&&(t.componentDidCatch(n,i||{}),r=t.__d),r)return t.__E=t}catch(l){n=l}throw n}},u=0,i=function(n){return null!=n&&void 0===n.constructor},_.prototype.setState=function(n,l){var u;u=null!=this.__s&&this.__s!==this.state?this.__s:this.__s=a({},this.state),\"function\"==typeof n&&(n=n(a({},u),this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),m(this))},_.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),m(this))},_.prototype.render=d,t=[],o=\"function\"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,g.__r=0,f=0;export{S as render,q as hydrate,v as createElement,v as h,d as Fragment,p as createRef,i as isValidElement,_ as Component,B as cloneElement,D as createContext,A as toChildArray,l as options};\n//# sourceMappingURL=preact.module.js.map\n","var n=function(t,s,r,e){var u;s[0]=0;for(var h=1;h<s.length;h++){var p=s[h++],a=s[h]?(s[0]|=p?1:2,r[s[h++]]):s[++h];3===p?e[0]=a:4===p?e[1]=Object.assign(e[1]||{},a):5===p?(e[1]=e[1]||{})[s[++h]]=a:6===p?e[1][s[++h]]+=a+\"\":p?(u=t.apply(a,n(t,a,r,[\"\",null])),e.push(u),a[0]?s[0]|=2:(s[h-2]=0,s[h]=u)):e.push(a)}return e},t=new Map;export default function(s){var r=t.get(this);return r||(r=new Map,t.set(this,r)),(r=n(this,r.get(s)||(r.set(s,r=function(n){for(var t,s,r=1,e=\"\",u=\"\",h=[0],p=function(n){1===r&&(n||(e=e.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,\"\")))?h.push(0,n,e):3===r&&(n||e)?(h.push(3,n,e),r=2):2===r&&\"...\"===e&&n?h.push(4,n,0):2===r&&e&&!n?h.push(5,0,!0,e):r>=5&&((e||!n&&5===r)&&(h.push(r,0,e,s),r=6),n&&(h.push(r,n,0,s),r=6)),e=\"\"},a=0;a<n.length;a++){a&&(1===r&&p(),p(a));for(var l=0;l<n[a].length;l++)t=n[a][l],1===r?\"<\"===t?(p(),h=[h],r=3):e+=t:4===r?\"--\"===e&&\">\"===t?(r=1,e=\"\"):e=t+e[0]:u?t===u?u=\"\":e+=t:'\"'===t||\"'\"===t?u=t:\">\"===t?(p(),r=1):r&&(\"=\"===t?(r=5,s=e,e=\"\"):\"/\"===t&&(r<5||\">\"===n[a][l+1])?(p(),3===r&&(h=h[0]),r=h,(h=h[0]).push(2,0,r),r=0):\" \"===t||\"\\t\"===t||\"\\n\"===t||\"\\r\"===t?(p(),r=2):e+=t),3===r&&\"!--\"===e&&(r=4,h=h[0])}return p(),h}(s)),r),arguments,[])).length>1?r:r[0]}\n","import{h as r,Component as o,render as t}from\"preact\";export{h,render,Component}from\"preact\";import e from\"htm\";var m=e.bind(r);export{m as html};\n","import{options as n}from\"preact\";var t,u,r,o=0,i=[],c=n.__b,f=n.__r,e=n.diffed,a=n.__c,v=n.unmount;function l(t,r){n.__h&&n.__h(u,t,o||r),o=0;var i=u.__H||(u.__H={__:[],__h:[]});return t>=i.__.length&&i.__.push({}),i.__[t]}function m(n){return o=1,p(w,n)}function p(n,r,o){var i=l(t++,2);return i.t=n,i.__c||(i.__=[o?o(r):w(void 0,r),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__=[t,i.__[1]],i.__c.setState({}))}],i.__c=u),i.__}function y(r,o){var i=l(t++,3);!n.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__H.__h.push(i))}function d(r,o){var i=l(t++,4);!n.__s&&k(i.__H,o)&&(i.__=r,i.__H=o,u.__h.push(i))}function h(n){return o=5,_(function(){return{current:n}},[])}function s(n,t,u){o=6,d(function(){return\"function\"==typeof n?(n(t()),function(){return n(null)}):n?(n.current=t(),function(){return n.current=null}):void 0},null==u?u:u.concat(n))}function _(n,u){var r=l(t++,7);return k(r.__H,u)&&(r.__=n(),r.__H=u,r.__h=n),r.__}function A(n,t){return o=8,_(function(){return n},t)}function F(n){var r=u.context[n.__c],o=l(t++,9);return o.c=n,r?(null==o.__&&(o.__=!0,r.sub(u)),r.props.value):n.__}function T(t,u){n.useDebugValue&&n.useDebugValue(u?u(t):t)}function q(n){var r=l(t++,10),o=m();return r.__=n,u.componentDidCatch||(u.componentDidCatch=function(n){r.__&&r.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]}function x(){for(var t;t=i.shift();)if(t.__P)try{t.__H.__h.forEach(g),t.__H.__h.forEach(j),t.__H.__h=[]}catch(u){t.__H.__h=[],n.__e(u,t.__v)}}n.__b=function(n){u=null,c&&c(n)},n.__r=function(n){f&&f(n),t=0;var r=(u=n.__c).__H;r&&(r.__h.forEach(g),r.__h.forEach(j),r.__h=[])},n.diffed=function(t){e&&e(t);var o=t.__c;o&&o.__H&&o.__H.__h.length&&(1!==i.push(o)&&r===n.requestAnimationFrame||((r=n.requestAnimationFrame)||function(n){var t,u=function(){clearTimeout(r),b&&cancelAnimationFrame(t),setTimeout(n)},r=setTimeout(u,100);b&&(t=requestAnimationFrame(u))})(x)),u=null},n.__c=function(t,u){u.some(function(t){try{t.__h.forEach(g),t.__h=t.__h.filter(function(n){return!n.__||j(n)})}catch(r){u.some(function(n){n.__h&&(n.__h=[])}),u=[],n.__e(r,t.__v)}}),a&&a(t,u)},n.unmount=function(t){v&&v(t);var u,r=t.__c;r&&r.__H&&(r.__H.__.forEach(function(n){try{g(n)}catch(n){u=n}}),u&&n.__e(u,r.__v))};var b=\"function\"==typeof requestAnimationFrame;function g(n){var t=u,r=n.__c;\"function\"==typeof r&&(n.__c=void 0,r()),u=t}function j(n){var t=u;n.__c=n.__(),u=t}function k(n,t){return!n||n.length!==t.length||t.some(function(t,u){return t!==n[u]})}function w(n,t){return\"function\"==typeof t?t(n):t}export{m as useState,p as useReducer,y as useEffect,d as useLayoutEffect,h as useRef,s as useImperativeHandle,_ as useMemo,A as useCallback,F as useContext,T as useDebugValue,q as useErrorBoundary};\n//# sourceMappingURL=hooks.module.js.map\n","/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import { coordEach } from \"@turf/meta\";\n/**\n * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.\n *\n * @name bbox\n * @param {GeoJSON} geojson any GeoJSON object\n * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);\n * var bbox = turf.bbox(line);\n * var bboxPolygon = turf.bboxPolygon(bbox);\n *\n * //addToMap\n * var addToMap = [line, bboxPolygon]\n */\nfunction bbox(geojson) {\n    var result = [Infinity, Infinity, -Infinity, -Infinity];\n    coordEach(geojson, function (coord) {\n        if (result[0] > coord[0]) {\n            result[0] = coord[0];\n        }\n        if (result[1] > coord[1]) {\n            result[1] = coord[1];\n        }\n        if (result[2] < coord[0]) {\n            result[2] = coord[0];\n        }\n        if (result[3] < coord[1]) {\n            result[3] = coord[1];\n        }\n    });\n    return result;\n}\nbbox[\"default\"] = bbox;\nexport default bbox;\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","import distance from \"@turf/distance\";\nimport { segmentReduce } from \"@turf/meta\";\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nexport default function length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance(coords[0], coords[1], options);\n    }, 0);\n}\n","import { degreesToRadians, radiansToDegrees } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Takes two {@link Point|points} and finds the geographic bearing between them,\n * i.e. the angle measured in degrees from the north line (0 degrees)\n *\n * @name bearing\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.final=false] calculates the final bearing if true\n * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)\n * @example\n * var point1 = turf.point([-75.343, 39.984]);\n * var point2 = turf.point([-75.534, 39.123]);\n *\n * var bearing = turf.bearing(point1, point2);\n *\n * //addToMap\n * var addToMap = [point1, point2]\n * point1.properties['marker-color'] = '#f00'\n * point2.properties['marker-color'] = '#0f0'\n * point1.properties.bearing = bearing\n */\nexport default function bearing(start, end, options) {\n    if (options === void 0) { options = {}; }\n    // Reverse calculation\n    if (options.final === true) {\n        return calculateFinalBearing(start, end);\n    }\n    var coordinates1 = getCoord(start);\n    var coordinates2 = getCoord(end);\n    var lon1 = degreesToRadians(coordinates1[0]);\n    var lon2 = degreesToRadians(coordinates2[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);\n    var b = Math.cos(lat1) * Math.sin(lat2) -\n        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n    return radiansToDegrees(Math.atan2(a, b));\n}\n/**\n * Calculates Final Bearing\n *\n * @private\n * @param {Coord} start starting Point\n * @param {Coord} end ending Point\n * @returns {number} bearing\n */\nfunction calculateFinalBearing(start, end) {\n    // Swap start & end\n    var bear = bearing(end, start);\n    bear = (bear + 180) % 360;\n    return bear;\n}\n","// http://en.wikipedia.org/wiki/Haversine_formula\n// http://www.movable-type.co.uk/scripts/latlong.html\nimport { degreesToRadians, lengthToRadians, point, radiansToDegrees, } from \"@turf/helpers\";\nimport { getCoord } from \"@turf/invariant\";\n/**\n * Takes a {@link Point} and calculates the location of a destination point given a distance in\n * degrees, radians, miles, or kilometers; and bearing in degrees.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name destination\n * @param {Coord} origin starting point\n * @param {number} distance distance from the origin point\n * @param {number} bearing ranging from -180 to 180\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians\n * @param {Object} [options.properties={}] Translate properties to Point\n * @returns {Feature<Point>} destination point\n * @example\n * var point = turf.point([-75.343, 39.984]);\n * var distance = 50;\n * var bearing = 90;\n * var options = {units: 'miles'};\n *\n * var destination = turf.destination(point, distance, bearing, options);\n *\n * //addToMap\n * var addToMap = [point, destination]\n * destination.properties['marker-color'] = '#f00';\n * point.properties['marker-color'] = '#0f0';\n */\nexport default function destination(origin, distance, bearing, options) {\n    if (options === void 0) { options = {}; }\n    // Handle input\n    var coordinates1 = getCoord(origin);\n    var longitude1 = degreesToRadians(coordinates1[0]);\n    var latitude1 = degreesToRadians(coordinates1[1]);\n    var bearingRad = degreesToRadians(bearing);\n    var radians = lengthToRadians(distance, options.units);\n    // Main\n    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +\n        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));\n    var longitude2 = longitude1 +\n        Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));\n    var lng = radiansToDegrees(longitude2);\n    var lat = radiansToDegrees(latitude2);\n    return point([lng, lat], options.properties);\n}\n","(function (global, factory) {\n  typeof exports === \"object\" && typeof module !== \"undefined\"\n    ? (module.exports = factory())\n    : typeof define === \"function\" && define.amd\n    ? define(factory)\n    : ((global =\n        typeof globalThis !== \"undefined\" ? globalThis : global || self),\n      (global.MapboxThirdPersonCamera = factory()));\n})(this, function () {\n  \"use strict\";\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false,\n    });\n    return Constructor;\n  }\n\n  var length_1$1 = length$1;\n  /**\n   * Calculates the length of a vec3\n   *\n   * @param {vec3} a vector to calculate length of\n   * @returns {Number} length of a\n   */\n\n  function length$1(a) {\n    var x = a[0],\n      y = a[1],\n      z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n  }\n\n  var normalize_1$1 = normalize$1;\n  /**\n   * Normalize a vec3\n   *\n   * @param {vec3} out the receiving vector\n   * @param {vec3} a vector to normalize\n   * @returns {vec3} out\n   */\n\n  function normalize$1(out, a) {\n    var x = a[0],\n      y = a[1],\n      z = a[2];\n    var len = x * x + y * y + z * z;\n\n    if (len > 0) {\n      //TODO: evaluate use of glm_invsqrt here?\n      len = 1 / Math.sqrt(len);\n      out[0] = a[0] * len;\n      out[1] = a[1] * len;\n      out[2] = a[2] * len;\n    }\n\n    return out;\n  }\n\n  var cross_1 = cross;\n  /**\n   * Computes the cross product of two vec3's\n   *\n   * @param {vec3} out the receiving vector\n   * @param {vec3} a the first operand\n   * @param {vec3} b the second operand\n   * @returns {vec3} out\n   */\n\n  function cross(out, a, b) {\n    var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2];\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n  }\n\n  var normalize_1 = normalize;\n  /**\n   * Normalize a vec2\n   *\n   * @param {vec2} out the receiving vector\n   * @param {vec2} a vector to normalize\n   * @returns {vec2} out\n   */\n\n  function normalize(out, a) {\n    var x = a[0],\n      y = a[1];\n    var len = x * x + y * y;\n\n    if (len > 0) {\n      //TODO: evaluate use of glm_invsqrt here?\n      len = 1 / Math.sqrt(len);\n      out[0] = a[0] * len;\n      out[1] = a[1] * len;\n    }\n\n    return out;\n  }\n\n  var length_1 = length;\n  /**\n   * Calculates the length of a vec2\n   *\n   * @param {vec2} a vector to calculate length of\n   * @returns {Number} length of a\n   */\n\n  function length(a) {\n    var x = a[0],\n      y = a[1];\n    return Math.sqrt(x * x + y * y);\n  }\n\n  var dot_1 = dot;\n  /**\n   * Calculates the dot product of two vec2's\n   *\n   * @param {vec2} a the first operand\n   * @param {vec2} b the second operand\n   * @returns {Number} dot product of a and b\n   */\n\n  function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n  }\n\n  var CameraController = /*#__PURE__*/ (function () {\n    function CameraController(map) {\n      var _ref =\n          arguments.length > 1 && arguments[1] !== undefined\n            ? arguments[1]\n            : {},\n        _ref$distance = _ref.distance,\n        distance = _ref$distance === void 0 ? 10000 : _ref$distance,\n        _ref$pitch = _ref.pitch,\n        pitch = _ref$pitch === void 0 ? 45 : _ref$pitch,\n        _ref$bearing = _ref.bearing,\n        bearing = _ref$bearing === void 0 ? 0 : _ref$bearing;\n\n      _classCallCheck(this, CameraController);\n\n      this.map = map;\n      this.MercatorCoordinate =\n        this.map.getFreeCameraOptions().position.constructor;\n      this._distanceTarget = distance;\n      this._pitchTarget = pitch;\n      this._bearingTarget = bearing;\n      this._centerTarget = this.center = this.MercatorCoordinate.fromLngLat(\n        map.transform.center\n      );\n      this._centerTarget = null;\n      this._center = this._previousCenter = null; //= this.MercatorCoordinate.fromLngLat(map.transform.center);\n\n      this._previousTime = NaN;\n      this._previousLookAtTime = NaN;\n      this._errorIntegral = [0, 0, 0];\n      const globalStrength = 1.0;\n      this.Kp_pan = 2.5 * globalStrength;\n      this.Ki_pan = 1.5 * globalStrength;\n      this.Kd_pan = 150 * globalStrength;\n      this.Kp_pitch = 5 * globalStrength;\n      this.Kp_dist = 2 * globalStrength;\n      this.Kp_bearing = 0 * globalStrength;\n      this._follow = 1 * globalStrength;\n      this._hadTerrain = false;\n    }\n\n    _createClass(CameraController, [\n      {\n        key: \"_cloneCoord\",\n        value: function _cloneCoord(coord) {\n          return new this.MercatorCoordinate(coord.x, coord.y, coord.z);\n        },\n      },\n      {\n        key: \"targetDistance\",\n        get: function get() {\n          return this._distanceTarget;\n        },\n        set: function set(value) {\n          this._distanceTarget = value;\n        },\n      },\n      {\n        key: \"targetPitch\",\n        get: function get() {\n          return this._pitchTarget;\n        },\n        set: function set(value) {\n          this._pitchTarget = value;\n        },\n      },\n      {\n        key: \"targetBearing\",\n        get: function get() {\n          return this._bearingTarget;\n        },\n        set: function set(value) {\n          this._bearingTarget = value;\n        },\n      },\n      {\n        key: \"targetCenter\",\n        get: function get() {\n          return this._centerTarget;\n        },\n        set: function set(center) {\n          var elevation = this.map.queryTerrainElevation(center) || 0;\n          this._centerTarget = this.MercatorCoordinate.fromLngLat(\n            center,\n            elevation\n          );\n        },\n      },\n      {\n        key: \"clear\",\n        value: function clear() {\n          this._center = null;\n        },\n      },\n      {\n        key: \"setPanPID\",\n        value: function setPanPID() {\n          var P =\n            arguments.length > 0 && arguments[0] !== undefined\n              ? arguments[0]\n              : 2.5;\n          var I =\n            arguments.length > 1 && arguments[1] !== undefined\n              ? arguments[1]\n              : 1.5;\n          var D =\n            arguments.length > 2 && arguments[2] !== undefined\n              ? arguments[2]\n              : 150;\n          this.Kp_pan = P;\n          this.Ki_pan = I;\n          this.Kd_pan = D;\n        },\n      },\n      {\n        key: \"setPitchP\",\n        value: function setPitchP() {\n          var P =\n            arguments.length > 0 && arguments[0] !== undefined\n              ? arguments[0]\n              : 2;\n          this.Kp_pitch = P;\n        },\n      },\n      {\n        key: \"setDistP\",\n        value: function setDistP() {\n          var P =\n            arguments.length > 0 && arguments[0] !== undefined\n              ? arguments[0]\n              : 2;\n          this.Kp_dist = P;\n        },\n      },\n      {\n        key: \"setBearingP\",\n        value: function setBearingP() {\n          var P =\n            arguments.length > 0 && arguments[0] !== undefined\n              ? arguments[0]\n              : 0;\n          this.Kp_bearing = P;\n        },\n      },\n      {\n        key: \"follow\",\n        get: function get() {\n          return this._follow;\n        },\n        set: function set(value) {\n          this._follow = Math.max(0, Math.min(1, value));\n        },\n      },\n      {\n        key: \"tick\",\n        value: function tick(t) {\n          if (!this._centerTarget) {\n            throw new Error(\"invalid camera controller state: no target set\");\n          }\n\n          var toMeters =\n            1 / this._centerTarget.meterInMercatorCoordinateUnits();\n\n          var cam = this.map.getFreeCameraOptions();\n          var hasTerrain = !!this.map.getTerrain(); // If there's no current position,\n\n          if (this._center === null) {\n            this._center = this._cloneCoord(this._centerTarget);\n            this._previousCenter = this._cloneCoord(this._centerTarget);\n            this._previousLookAtTime = t;\n            var dist = this._distanceTarget / toMeters;\n            var elevation =\n              this.map.queryTerrainElevation(this._centerTarget.toLngLat()) ||\n              0;\n            if (elevation !== null) this._centerTarget.z = elevation / toMeters;\n            var theta = (this._bearingTarget * Math.PI) / 180;\n            var phi = (this._pitchTarget * Math.PI) / 180;\n            cam.position.x =\n              this._center.x + Math.sin(phi) * Math.sin(theta) * dist;\n            cam.position.y =\n              this._center.y + Math.sin(phi) * Math.cos(theta) * dist;\n            cam.position.z =\n              this._center.z + Math.cos(phi) * dist + elevation / toMeters;\n            cam.lookAtPoint(this._center.toLngLat());\n            this.map.setFreeCameraOptions(cam);\n            this._hadTerrain = hasTerrain;\n            return;\n          }\n\n          var dt = isNaN(this._previousTime)\n            ? 0\n            : Math.min(t - this._previousTime, 32) / 1000;\n          this._previousTime = t; // Compensate for terrain being added/removed\n\n          if (hasTerrain && !this._hadTerrain) {\n            var el = this.map.queryTerrainElevation(\n              this._centerTarget.toLngLat()\n            );\n\n            if (el !== null) {\n              this._centerTarget.z += el / toMeters;\n              this._hadTerrain = hasTerrain;\n            }\n          } else if (!hasTerrain && this._hadTerrain) {\n            this._centerTarget.z = 0;\n            this._hadTerrain = hasTerrain;\n          } // Overwrite this. We can't look at a point that's not on the ground. But otherwise proceed as normal.\n\n          this._center.z = this._centerTarget.z;\n          var mPanErr = [\n            this._centerTarget.x - this._center.x,\n            this._centerTarget.y - this._center.y,\n            this._centerTarget.z - this._center.z,\n          ]; // Use only the first two coordinates!\n\n          var targetErrorMeters = length_1(mPanErr) * toMeters;\n          this._errorIntegral[0] += mPanErr[0] * dt;\n          this._errorIntegral[1] += mPanErr[1] * dt;\n          this._errorIntegral[2] += mPanErr[2] * dt;\n          var sky = [0, 0, 1];\n          var vcam = [\n            this._centerTarget.x - cam.position.x,\n            this._centerTarget.y - cam.position.y,\n            this._centerTarget.z - cam.position.z,\n          ];\n          var e0cam = normalize_1$1([], vcam);\n          var e1cam = normalize_1$1([], cross_1([], e0cam, sky));\n          var e2cam = cross_1([], e1cam, e0cam); // already normalized\n\n          var camDist = length_1$1(vcam) * toMeters;\n          var camDistForce = 1.0 - camDist / this._distanceTarget;\n          var camPitch = Math.acos(-vcam[2] / length_1$1(vcam));\n          var pitchForce = this._pitchTarget * (Math.PI / 180) - camPitch;\n          var bearingTarget = [\n            Math.cos(this._bearingTarget * (Math.PI / 180)),\n            Math.sin(this._bearingTarget * (Math.PI / 180)),\n          ];\n          var curBearing = normalize_1([], [e0cam[0], e0cam[1]]);\n          var b = dot_1(bearingTarget, curBearing) * Math.sin(camPitch);\n          var bearingForce = [-b * curBearing[1], b * curBearing[0]]; // Store this for later\n\n          var lx = this._center.x;\n          var ly = this._center.y;\n          var lz = this._center.z;\n          var pani = this.Ki_pan;\n          var panp = this.Kp_pan;\n          var pand = this.Kd_pan;\n          var distp = this.Kp_dist * (camDist / toMeters);\n          var pitchp = this.Kp_pitch * (camDist / toMeters);\n          var bearingp = this.Kp_bearing * (camDist / toMeters);\n\n          if (\n            targetErrorMeters * panp > this._distanceTarget / 1000 ||\n            Math.abs(camDistForce) * distp > 1e-8 ||\n            Math.abs(pitchForce) * pitchp > 1e-8 ||\n            length_1(bearingForce) * bearingp > 1e-8\n          ) {\n            var dlookdt = [0, 0, 0];\n\n            if (\n              this._previousCenter &&\n              !isNaN(this._previousLookAtTime) &&\n              t > this._previousLookAtTime\n            ) {\n              var _dt = t - this._previousLookAtTime;\n\n              dlookdt[0] = (this._center.x - this._previousCenter.x) / _dt;\n              dlookdt[1] = (this._center.y - this._previousCenter.y) / _dt;\n              dlookdt[2] = (this._center.z - this._previousCenter.z) / _dt;\n            } // Compute PID pan force\n\n            var panx =\n              (mPanErr[0] * panp +\n                this._errorIntegral[0] * pani +\n                dlookdt[0] * pand) *\n              dt;\n            var pany =\n              (mPanErr[1] * panp +\n                this._errorIntegral[1] * pani +\n                dlookdt[1] * pand) *\n              dt;\n            var panz =\n              (mPanErr[2] * panp +\n                this._errorIntegral[2] * pani +\n                dlookdt[2] * pand) *\n              dt; // Mutate the look-at point in-place\n\n            this._center.x += panx;\n            this._center.y += pany;\n            this._center.z += panz; // Pan the camera together with lookAt, only when *not* follow mode, which instead\n            // prefers to let the camera trail behind rather than pulling it together with the\n            // lookAt point.\n\n            cam.position.x += panx * (1 - this._follow);\n            cam.position.y += pany * (1 - this._follow);\n            cam.position.z += panz * (1 - this._follow); // Pitch the camera\n\n            cam.position.x -= e2cam[0] * pitchForce * pitchp * dt;\n            cam.position.y -= e2cam[1] * pitchForce * pitchp * dt;\n            cam.position.z -= e2cam[2] * pitchForce * pitchp * dt; // Adjust the bearing\n\n            cam.position.x += bearingForce[0] * bearingp * dt;\n            cam.position.y += bearingForce[1] * bearingp * dt; // Adjust the camera distance\n\n            normalize_1$1(vcam, vcam);\n            cam.position.x -= vcam[0] * camDistForce * distp * dt;\n            cam.position.y -= vcam[1] * camDistForce * distp * dt;\n            cam.position.z -= vcam[2] * camDistForce * distp * dt;\n            cam.lookAtPoint(this._center.toLngLat());\n            this.map.setFreeCameraOptions(cam);\n          }\n\n          this._previousCenter = new this.MercatorCoordinate(lx, ly, lz);\n          this._previousLookAtTime = t;\n        },\n        /*\n      fitBounds(bounds) {\n        bounds = bounds.flat();\n        const lonCen = 0.5 * (bounds[2] + bounds[0])\n        const latCen = 0.5 * (bounds[3] + bounds[1])\n        const dLon = 0.5 * (bounds[2] - bounds[0])\n        const dLat = 0.5 * (bounds[3] - bounds[1])\n        const lonDist = distance(point([lonCen, latCen]), point([lonCen - dLon, latCen]), {units: 'meters'});\n        const latDist = distance(point([lonCen, latCen]), point([lonCen, latCen - dLat]), {units: 'meters'});\n        const tanFov = Math.tan(this.map.transform.fov * Math.PI / 180);\n        const ar = window.innerWidth / window.innerHeight;\n        const latCameraDist = 2 * latDist / tanFov;\n        const lonCameraDist = 2 * lonDist / tanFov / ar;\n         this._distanceTarget = Math.max(latCameraDist, lonCameraDist) * 1.5;\n        this.setTargetBearing(0);\n        this.setTargetPitch(5);\n        this.setTargetCenter([lonCen, latCen]);\n      }\n      */\n      },\n    ]);\n\n    return CameraController;\n  })();\n\n  return CameraController;\n});\n//# sourceMappingURL=mapbox-gl-third-person-camera.js.map\n","import { feature } from \"@turf/helpers\";\nimport { getCoords, getType } from \"@turf/invariant\";\n// To-Do => Improve Typescript GeoJSON handling\n/**\n * Removes redundant coordinates from any GeoJSON Geometry.\n *\n * @name cleanCoords\n * @param {Geometry|Feature} geojson Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated\n * @returns {Geometry|Feature} the cleaned input Feature/Geometry\n * @example\n * var line = turf.lineString([[0, 0], [0, 2], [0, 5], [0, 8], [0, 8], [0, 10]]);\n * var multiPoint = turf.multiPoint([[0, 0], [0, 0], [2, 2]]);\n *\n * turf.cleanCoords(line).geometry.coordinates;\n * //= [[0, 0], [0, 10]]\n *\n * turf.cleanCoords(multiPoint).geometry.coordinates;\n * //= [[0, 0], [2, 2]]\n */\nfunction cleanCoords(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Backwards compatible with v4.0\n    var mutate = typeof options === \"object\" ? options.mutate : options;\n    if (!geojson)\n        throw new Error(\"geojson is required\");\n    var type = getType(geojson);\n    // Store new \"clean\" points in this Array\n    var newCoords = [];\n    switch (type) {\n        case \"LineString\":\n            newCoords = cleanLine(geojson);\n            break;\n        case \"MultiLineString\":\n        case \"Polygon\":\n            getCoords(geojson).forEach(function (line) {\n                newCoords.push(cleanLine(line));\n            });\n            break;\n        case \"MultiPolygon\":\n            getCoords(geojson).forEach(function (polygons) {\n                var polyPoints = [];\n                polygons.forEach(function (ring) {\n                    polyPoints.push(cleanLine(ring));\n                });\n                newCoords.push(polyPoints);\n            });\n            break;\n        case \"Point\":\n            return geojson;\n        case \"MultiPoint\":\n            var existing = {};\n            getCoords(geojson).forEach(function (coord) {\n                var key = coord.join(\"-\");\n                if (!Object.prototype.hasOwnProperty.call(existing, key)) {\n                    newCoords.push(coord);\n                    existing[key] = true;\n                }\n            });\n            break;\n        default:\n            throw new Error(type + \" geometry not supported\");\n    }\n    // Support input mutation\n    if (geojson.coordinates) {\n        if (mutate === true) {\n            geojson.coordinates = newCoords;\n            return geojson;\n        }\n        return { type: type, coordinates: newCoords };\n    }\n    else {\n        if (mutate === true) {\n            geojson.geometry.coordinates = newCoords;\n            return geojson;\n        }\n        return feature({ type: type, coordinates: newCoords }, geojson.properties, {\n            bbox: geojson.bbox,\n            id: geojson.id,\n        });\n    }\n}\n/**\n * Clean Coords\n *\n * @private\n * @param {Array<number>|LineString} line Line\n * @returns {Array<number>} Cleaned coordinates\n */\nfunction cleanLine(line) {\n    var points = getCoords(line);\n    // handle \"clean\" segment\n    if (points.length === 2 && !equals(points[0], points[1]))\n        return points;\n    var newPoints = [];\n    var secondToLast = points.length - 1;\n    var newPointsLength = newPoints.length;\n    newPoints.push(points[0]);\n    for (var i = 1; i < secondToLast; i++) {\n        var prevAddedPoint = newPoints[newPoints.length - 1];\n        if (points[i][0] === prevAddedPoint[0] &&\n            points[i][1] === prevAddedPoint[1])\n            continue;\n        else {\n            newPoints.push(points[i]);\n            newPointsLength = newPoints.length;\n            if (newPointsLength > 2) {\n                if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n                    newPoints.splice(newPoints.length - 2, 1);\n            }\n        }\n    }\n    newPoints.push(points[points.length - 1]);\n    newPointsLength = newPoints.length;\n    if (equals(points[0], points[points.length - 1]) && newPointsLength < 4)\n        throw new Error(\"invalid polygon\");\n    if (isPointOnLineSegment(newPoints[newPointsLength - 3], newPoints[newPointsLength - 1], newPoints[newPointsLength - 2]))\n        newPoints.splice(newPoints.length - 2, 1);\n    return newPoints;\n}\n/**\n * Compares two points and returns if they are equals\n *\n * @private\n * @param {Position} pt1 point\n * @param {Position} pt2 point\n * @returns {boolean} true if they are equals\n */\nfunction equals(pt1, pt2) {\n    return pt1[0] === pt2[0] && pt1[1] === pt2[1];\n}\n/**\n * Returns if `point` is on the segment between `start` and `end`.\n * Borrowed from `@turf/boolean-point-on-line` to speed up the evaluation (instead of using the module as dependency)\n *\n * @private\n * @param {Position} start coord pair of start of line\n * @param {Position} end coord pair of end of line\n * @param {Position} point coord pair of point to check\n * @returns {boolean} true/false\n */\nfunction isPointOnLineSegment(start, end, point) {\n    var x = point[0], y = point[1];\n    var startX = start[0], startY = start[1];\n    var endX = end[0], endY = end[1];\n    var dxc = x - startX;\n    var dyc = y - startY;\n    var dxl = endX - startX;\n    var dyl = endY - startY;\n    var cross = dxc * dyl - dyc * dxl;\n    if (cross !== 0)\n        return false;\n    else if (Math.abs(dxl) >= Math.abs(dyl))\n        return dxl > 0 ? startX <= x && x <= endX : endX <= x && x <= startX;\n    else\n        return dyl > 0 ? startY <= y && y <= endY : endY <= y && y <= startY;\n}\nexport default cleanCoords;\n","/**\n * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.\n * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.\n *\n * @name clone\n * @param {GeoJSON} geojson GeoJSON Object\n * @returns {GeoJSON} cloned GeoJSON Object\n * @example\n * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});\n *\n * var lineCloned = turf.clone(line);\n */\nfunction clone(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    switch (geojson.type) {\n        case \"Feature\":\n            return cloneFeature(geojson);\n        case \"FeatureCollection\":\n            return cloneFeatureCollection(geojson);\n        case \"Point\":\n        case \"LineString\":\n        case \"Polygon\":\n        case \"MultiPoint\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\":\n        case \"GeometryCollection\":\n            return cloneGeometry(geojson);\n        default:\n            throw new Error(\"unknown GeoJSON type\");\n    }\n}\n/**\n * Clone Feature\n *\n * @private\n * @param {Feature<any>} geojson GeoJSON Feature\n * @returns {Feature<any>} cloned Feature\n */\nfunction cloneFeature(geojson) {\n    var cloned = { type: \"Feature\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"properties\":\n            case \"geometry\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add properties & geometry last\n    cloned.properties = cloneProperties(geojson.properties);\n    cloned.geometry = cloneGeometry(geojson.geometry);\n    return cloned;\n}\n/**\n * Clone Properties\n *\n * @private\n * @param {Object} properties GeoJSON Properties\n * @returns {Object} cloned Properties\n */\nfunction cloneProperties(properties) {\n    var cloned = {};\n    if (!properties) {\n        return cloned;\n    }\n    Object.keys(properties).forEach(function (key) {\n        var value = properties[key];\n        if (typeof value === \"object\") {\n            if (value === null) {\n                // handle null\n                cloned[key] = null;\n            }\n            else if (Array.isArray(value)) {\n                // handle Array\n                cloned[key] = value.map(function (item) {\n                    return item;\n                });\n            }\n            else {\n                // handle generic Object\n                cloned[key] = cloneProperties(value);\n            }\n        }\n        else {\n            cloned[key] = value;\n        }\n    });\n    return cloned;\n}\n/**\n * Clone Feature Collection\n *\n * @private\n * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection\n * @returns {FeatureCollection<any>} cloned Feature Collection\n */\nfunction cloneFeatureCollection(geojson) {\n    var cloned = { type: \"FeatureCollection\" };\n    // Preserve Foreign Members\n    Object.keys(geojson).forEach(function (key) {\n        switch (key) {\n            case \"type\":\n            case \"features\":\n                return;\n            default:\n                cloned[key] = geojson[key];\n        }\n    });\n    // Add features\n    cloned.features = geojson.features.map(function (feature) {\n        return cloneFeature(feature);\n    });\n    return cloned;\n}\n/**\n * Clone Geometry\n *\n * @private\n * @param {Geometry<any>} geometry GeoJSON Geometry\n * @returns {Geometry<any>} cloned Geometry\n */\nfunction cloneGeometry(geometry) {\n    var geom = { type: geometry.type };\n    if (geometry.bbox) {\n        geom.bbox = geometry.bbox;\n    }\n    if (geometry.type === \"GeometryCollection\") {\n        geom.geometries = geometry.geometries.map(function (g) {\n            return cloneGeometry(g);\n        });\n        return geom;\n    }\n    geom.coordinates = deepSlice(geometry.coordinates);\n    return geom;\n}\n/**\n * Deep Slice coordinates\n *\n * @private\n * @param {Coordinates} coords Coordinates\n * @returns {Coordinates} all coordinates sliced\n */\nfunction deepSlice(coords) {\n    var cloned = coords;\n    if (typeof cloned[0] !== \"object\") {\n        return cloned.slice();\n    }\n    return cloned.map(function (coord) {\n        return deepSlice(coord);\n    });\n}\nexport default clone;\n","import cleanCoords from '@turf/clean-coords';\nimport clone from '@turf/clone';\nimport { geomEach } from '@turf/meta';\nimport { isObject } from '@turf/helpers';\n\n/*\n (c) 2013, Vladimir Agafonkin\n Simplify.js, a high-performance JS polyline simplification library\n mourner.github.io/simplify-js\n*/\n\n// to suit your point format, run search/replace for '.x' and '.y';\n// for 3D version, see 3d branch (configurability would draw significant performance overhead)\n\n// square distance between 2 points\nfunction getSqDist(p1, p2) {\n  var dx = p1.x - p2.x,\n    dy = p1.y - p2.y;\n\n  return dx * dx + dy * dy;\n}\n\n// square distance from a point to a segment\nfunction getSqSegDist(p, p1, p2) {\n  var x = p1.x,\n    y = p1.y,\n    dx = p2.x - x,\n    dy = p2.y - y;\n\n  if (dx !== 0 || dy !== 0) {\n    var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);\n\n    if (t > 1) {\n      x = p2.x;\n      y = p2.y;\n    } else if (t > 0) {\n      x += dx * t;\n      y += dy * t;\n    }\n  }\n\n  dx = p.x - x;\n  dy = p.y - y;\n\n  return dx * dx + dy * dy;\n}\n// rest of the code doesn't care about point format\n\n// basic distance-based simplification\nfunction simplifyRadialDist(points, sqTolerance) {\n  var prevPoint = points[0],\n    newPoints = [prevPoint],\n    point;\n\n  for (var i = 1, len = points.length; i < len; i++) {\n    point = points[i];\n\n    if (getSqDist(point, prevPoint) > sqTolerance) {\n      newPoints.push(point);\n      prevPoint = point;\n    }\n  }\n\n  if (prevPoint !== point) newPoints.push(point);\n\n  return newPoints;\n}\n\nfunction simplifyDPStep(points, first, last, sqTolerance, simplified) {\n  var maxSqDist = sqTolerance,\n    index;\n\n  for (var i = first + 1; i < last; i++) {\n    var sqDist = getSqSegDist(points[i], points[first], points[last]);\n\n    if (sqDist > maxSqDist) {\n      index = i;\n      maxSqDist = sqDist;\n    }\n  }\n\n  if (maxSqDist > sqTolerance) {\n    if (index - first > 1)\n      simplifyDPStep(points, first, index, sqTolerance, simplified);\n    simplified.push(points[index]);\n    if (last - index > 1)\n      simplifyDPStep(points, index, last, sqTolerance, simplified);\n  }\n}\n\n// simplification using Ramer-Douglas-Peucker algorithm\nfunction simplifyDouglasPeucker(points, sqTolerance) {\n  var last = points.length - 1;\n\n  var simplified = [points[0]];\n  simplifyDPStep(points, 0, last, sqTolerance, simplified);\n  simplified.push(points[last]);\n\n  return simplified;\n}\n\n// both algorithms combined for awesome performance\nfunction simplify(points, tolerance, highestQuality) {\n  if (points.length <= 2) return points;\n\n  var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;\n\n  points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);\n  points = simplifyDouglasPeucker(points, sqTolerance);\n\n  return points;\n}\n\n/**\n * Takes a {@link GeoJSON} object and returns a simplified version. Internally uses\n * [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification using the Ramer-Douglas-Peucker algorithm.\n *\n * @name simplify\n * @param {GeoJSON} geojson object to be simplified\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.tolerance=1] simplification tolerance\n * @param {boolean} [options.highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @param {boolean} [options.mutate=false] allows GeoJSON input to be mutated (significant performance increase if true)\n * @returns {GeoJSON} a simplified GeoJSON\n * @example\n * var geojson = turf.polygon([[\n *   [-70.603637, -33.399918],\n *   [-70.614624, -33.395332],\n *   [-70.639343, -33.392466],\n *   [-70.659942, -33.394759],\n *   [-70.683975, -33.404504],\n *   [-70.697021, -33.419406],\n *   [-70.701141, -33.434306],\n *   [-70.700454, -33.446339],\n *   [-70.694274, -33.458369],\n *   [-70.682601, -33.465816],\n *   [-70.668869, -33.472117],\n *   [-70.646209, -33.473835],\n *   [-70.624923, -33.472117],\n *   [-70.609817, -33.468107],\n *   [-70.595397, -33.458369],\n *   [-70.587158, -33.442901],\n *   [-70.587158, -33.426283],\n *   [-70.590591, -33.414248],\n *   [-70.594711, -33.406224],\n *   [-70.603637, -33.399918]\n * ]]);\n * var options = {tolerance: 0.01, highQuality: false};\n * var simplified = turf.simplify(geojson, options);\n *\n * //addToMap\n * var addToMap = [geojson, simplified]\n */\nfunction simplify$1(geojson, options) {\n  // Optional parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var tolerance = options.tolerance !== undefined ? options.tolerance : 1;\n  var highQuality = options.highQuality || false;\n  var mutate = options.mutate || false;\n\n  if (!geojson) throw new Error(\"geojson is required\");\n  if (tolerance && tolerance < 0) throw new Error(\"invalid tolerance\");\n\n  // Clone geojson to avoid side effects\n  if (mutate !== true) geojson = clone(geojson);\n\n  geomEach(geojson, function (geom) {\n    simplifyGeom(geom, tolerance, highQuality);\n  });\n  return geojson;\n}\n\n/**\n * Simplifies a feature's coordinates\n *\n * @private\n * @param {Geometry} geometry to be simplified\n * @param {number} [tolerance=1] simplification tolerance\n * @param {boolean} [highQuality=false] whether or not to spend more time to create a higher-quality simplification with a different algorithm\n * @returns {Geometry} output\n */\nfunction simplifyGeom(geometry, tolerance, highQuality) {\n  var type = geometry.type;\n\n  // \"unsimplyfiable\" geometry types\n  if (type === \"Point\" || type === \"MultiPoint\") return geometry;\n\n  // Remove any extra coordinates\n  cleanCoords(geometry, true);\n\n  var coordinates = geometry.coordinates;\n  switch (type) {\n    case \"LineString\":\n      geometry[\"coordinates\"] = simplifyLine(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiLineString\":\n      geometry[\"coordinates\"] = coordinates.map(function (lines) {\n        return simplifyLine(lines, tolerance, highQuality);\n      });\n      break;\n    case \"Polygon\":\n      geometry[\"coordinates\"] = simplifyPolygon(\n        coordinates,\n        tolerance,\n        highQuality\n      );\n      break;\n    case \"MultiPolygon\":\n      geometry[\"coordinates\"] = coordinates.map(function (rings) {\n        return simplifyPolygon(rings, tolerance, highQuality);\n      });\n  }\n  return geometry;\n}\n\n/**\n * Simplifies the coordinates of a LineString with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<number>>} simplified coords\n */\nfunction simplifyLine(coordinates, tolerance, highQuality) {\n  return simplify(\n    coordinates.map(function (coord) {\n      return { x: coord[0], y: coord[1], z: coord[2] };\n    }),\n    tolerance,\n    highQuality\n  ).map(function (coords) {\n    return coords.z ? [coords.x, coords.y, coords.z] : [coords.x, coords.y];\n  });\n}\n\n/**\n * Simplifies the coordinates of a Polygon with simplify-js\n *\n * @private\n * @param {Array<number>} coordinates to be processed\n * @param {number} tolerance simplification tolerance\n * @param {boolean} highQuality whether or not to spend more time to create a higher-quality\n * @returns {Array<Array<Array<number>>>} simplified coords\n */\nfunction simplifyPolygon(coordinates, tolerance, highQuality) {\n  return coordinates.map(function (ring) {\n    var pts = ring.map(function (coord) {\n      return { x: coord[0], y: coord[1] };\n    });\n    if (pts.length < 4) {\n      throw new Error(\"invalid polygon\");\n    }\n    var simpleRing = simplify(pts, tolerance, highQuality).map(function (\n      coords\n    ) {\n      return [coords.x, coords.y];\n    });\n    //remove 1 percent of tolerance until enough points to make a triangle\n    while (!checkValidity(simpleRing)) {\n      tolerance -= tolerance * 0.01;\n      simpleRing = simplify(pts, tolerance, highQuality).map(function (\n        coords\n      ) {\n        return [coords.x, coords.y];\n      });\n    }\n    if (\n      simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0] ||\n      simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1]\n    ) {\n      simpleRing.push(simpleRing[0]);\n    }\n    return simpleRing;\n  });\n}\n\n/**\n * Returns true if ring has at least 3 coordinates and its first coordinate is the same as its last\n *\n * @private\n * @param {Array<number>} ring coordinates to be checked\n * @returns {boolean} true if valid\n */\nfunction checkValidity(ring) {\n  if (ring.length < 3) return false;\n  //if the last point is the same as the first, it's not a triangle\n  return !(\n    ring.length === 3 &&\n    ring[2][0] === ring[0][0] &&\n    ring[2][1] === ring[0][1]\n  );\n}\n\nexport default simplify$1;\n","import simplify from \"@turf/simplify\";\nimport { featureCollection, lineString } from \"@turf/helpers\";\nimport length from \"@turf/length\";\nimport bbox from \"@turf/bbox\";\nimport along from \"@turf/along\";\n\nconst EMPTY_GEOJSON = {\n  type: \"FeatureCollection\",\n  features: [],\n};\n\nconst metersToFeet = (meters) => (meters * 5280) / 1609;\n\nclass Route {\n  constructor(geojson) {\n    this.geojson = geojson;\n    this.simplified = simplify(geojson, {\n      tolerance: 0.0001,\n      highQuality: true,\n    });\n    this.elevationProfiles = [];\n\n    this.bboxes = {\n      all: bbox(geojson),\n      foot: bbox(\n        featureCollection(\n          geojson.features.filter((x) => x.properties.mode === \"foot\")\n        )\n      ),\n    };\n\n    this.computeElevationProfile();\n    this._lengthCache = [];\n  }\n\n  computeElevationProfile() {\n    for (\n      let featureIndex = 0;\n      featureIndex < this.geojson.features.length;\n      featureIndex++\n    ) {\n      const feature = this.geojson.features[featureIndex];\n\n      if (feature.properties.mode !== \"foot\") continue;\n\n      const coords = feature.geometry.coordinates;\n      const profile = [\n        {\n          distance: 0,\n          elevation: metersToFeet(coords[0][2]),\n        },\n      ];\n\n      let distance = 0;\n      for (let i = 1; i < coords.length; i++) {\n        distance += length(lineString([coords[i - 1], coords[i]]), {\n          units: \"kilometers\",\n        });\n        profile.push({ distance, elevation: metersToFeet(coords[i][2]) });\n      }\n      const els = profile.map((p) => p.elevation);\n      const els2 = els.slice();\n\n      for (let j = 0; j < 10; j++) {\n        for (let i = 1; i < els.length - 1; i++) {\n          els2[i] = 0.5 * (els[i - 1] + els[i + 1]);\n        }\n        [els, els2] = [els2, els];\n      }\n      for (let i = 1; i < els.length - 1; i++) {\n        profile[i].elevation = els[i];\n      }\n      this.elevationProfiles[featureIndex] = profile;\n    }\n  }\n\n  getFootFeatureIndex() {\n    for (let i = 0; i < this.geojson.features.length; i++) {\n      if (this.geojson.features[i].properties.mode === \"foot\") return i;\n    }\n    return -1;\n  }\n\n  getElevationProfile() {\n    const featureIndex = this.getFootFeatureIndex();\n    return this.elevationProfiles[featureIndex];\n  }\n\n  featureLength(featureIndex) {\n    if (this._lengthCache[featureIndex] === undefined) {\n      this._lengthCache[featureIndex] = length(\n        this.geojson.features[featureIndex].geometry\n      );\n    }\n    return this._lengthCache[featureIndex];\n  }\n\n  getBbox({ mode = \"all\" } = {}) {\n    return this.bboxes[mode];\n  }\n\n  getGeojson() {\n    return this.geojson;\n  }\n\n  evaluate(position) {\n    const featureIndex = Math.min(\n      Math.floor(position),\n      this.geojson.features.length - 1\n    );\n    const featureProgress = position - featureIndex;\n\n    const feature = this.geojson.features[featureIndex];\n\n    const pos = along(\n      feature.geometry,\n      this.featureLength(featureIndex) * featureProgress,\n      { units: \"kilometers\" }\n    );\n\n    return [pos.geometry.coordinates, feature];\n  }\n\n  getMileMarkers() {\n    if (!this.geojson) return EMPTY_GEOJSON;\n\n    const markers = [];\n    for (const feature of this.geojson.features) {\n      markers.push(...(feature.properties?.markers?.mi?.features || []));\n    }\n    return featureCollection(markers);\n  }\n}\n\nexport default Route;\n","import bearing from \"@turf/bearing\";\nimport destination from \"@turf/destination\";\nimport measureDistance from \"@turf/distance\";\nimport { point } from \"@turf/helpers\";\nimport { getGeom } from \"@turf/invariant\";\n/**\n * Takes a {@link LineString} and returns a {@link Point} at a specified distance along the line.\n *\n * @name along\n * @param {Feature<LineString>} line input line\n * @param {number} distance distance along the line\n * @param {Object} [options] Optional parameters\n * @param {string} [options.units=\"kilometers\"] can be degrees, radians, miles, or kilometers\n * @returns {Feature<Point>} Point `distance` `units` along the line\n * @example\n * var line = turf.lineString([[-83, 30], [-84, 36], [-78, 41]]);\n * var options = {units: 'miles'};\n *\n * var along = turf.along(line, 200, options);\n *\n * //addToMap\n * var addToMap = [along, line]\n */\nexport default function along(line, distance, options) {\n    if (options === void 0) { options = {}; }\n    // Get Coords\n    var geom = getGeom(line);\n    var coords = geom.coordinates;\n    var travelled = 0;\n    for (var i = 0; i < coords.length; i++) {\n        if (distance >= travelled && i === coords.length - 1) {\n            break;\n        }\n        else if (travelled >= distance) {\n            var overshot = distance - travelled;\n            if (!overshot) {\n                return point(coords[i]);\n            }\n            else {\n                var direction = bearing(coords[i], coords[i - 1]) - 180;\n                var interpolated = destination(coords[i], overshot, direction, options);\n                return interpolated;\n            }\n        }\n        else {\n            travelled += measureDistance(coords[i], coords[i + 1], options);\n        }\n    }\n    return point(coords[coords.length - 1]);\n}\n","import bbox from \"@turf/bbox\";\nimport length from \"@turf/length\";\nimport along from \"@turf/along\";\nimport { point } from \"@turf/helpers\";\nimport CameraController from \"../../lib/mapbox-gl-third-person-camera.js\";\nimport Route from \"./route.js\";\n\nif (typeof window !== \"undefined\" && typeof window.mapboxgl !== \"undefined\") {\n  mapboxgl.accessToken = process.env.MAPBOX_ACCESS_TOKEN;\n}\n\nconst HOME_FADE_TEXT_LAYERS = [\n  \"natural-line-label\",\n  \"natural-point-label\",\n  \"water-line-label\",\n  \"water-point-label\",\n  \"poi-label\",\n  \"transit-label\",\n  \"settlement-subdivision-label\",\n  \"settlement-minor-label\",\n  \"settlement-major-label\",\n  \"state-label\",\n  \"country-label\",\n];\n\nconst EMPTY_GEOJSON = {\n  type: \"FeatureCollection\",\n  features: [],\n};\n\nconst MARKER = point([0, 0]);\n\nclass MapController {\n  constructor(container, bounds, padding, onload) {\n    this.map = window.map = new mapboxgl.Map({\n      container,\n      //style: \"mapbox://styles/rsreusser/ckt5f72080l7r18quyld7h4si/draft\",\n      style: \"mapbox://styles/rsreusser/ckt5f72080l7r18quyld7h4si\",\n      scrollZoom: false,\n      boxZoom: false,\n      dragRotate: false,\n      dragPan: false,\n      keyboard: false,\n      doubleClickZoom: false,\n      touchZoomRotate: false,\n      interactive: false,\n      pitch: 0,\n      bounds,\n      logoPosition: \"top-right\",\n      fitBoundsOptions: { padding },\n    });\n\n    //map.addControl(new mapboxgl.ScaleControl({unit: 'imperial'}), 'bottom-right');\n\n    //map.showPadding = true;\n\n    this.camera = window.camera = new CameraController(this.map);\n\n    this.map.on(\"load\", () => {\n      map.transform.fov = 50;\n\n      map.loadImage(\"pin.png\", (error, image) => {\n        if (error) throw error;\n        map.addImage(\"pin\", image);\n        this.map.addSource(\"mapbox-dem\", {\n          type: \"raster-dem\",\n          url: \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n          tileSize: 512,\n          maxzoom: 14,\n        });\n\n        const storedHillshadeResolution = localStorage.getItem(\n          \"hillshadeResolution\"\n        );\n\n        const useCustomHillshade = !!storedHillshadeResolution;\n        const hillshadeSource = useCustomHillshade ? \"mapbox-dem-2\" : null;\n\n        if (useCustomHillshade) {\n          this.map.addSource(\"mapbox-dem-2\", {\n            type: \"raster-dem\",\n            url: \"mapbox://mapbox.mapbox-terrain-dem-v1\",\n            tileSize: storedHillshadeResolution,\n            maxzoom: 14,\n          });\n        }\n\n        this.map.getSource(\"mapbox://mapbox.satellite\").maxzoom = 15;\n\n        this.map.addLayer(\n          {\n            id: \"hillshade\",\n            source: useCustomHillshade ? \"mapbox-dem-2\" : \"mapbox-dem\",\n            type: \"hillshade\",\n            paint: {\n              \"hillshade-exaggeration\": 1,\n              \"hillshade-highlight-color\": \"rgba(255,230,210,0.3)\",\n              \"hillshade-shadow-color\": \"rgba(0,10,20,1)\",\n              \"hillshade-illumination-anchor\": \"map\",\n              \"hillshade-illumination-direction\": 180,\n            },\n          },\n          \"ferry\"\n        );\n\n        this.map.addSource(\"route\", {\n          type: \"geojson\",\n          data: EMPTY_GEOJSON,\n        });\n\n        this.map.addSource(\"mile-markers\", {\n          type: \"geojson\",\n          data: EMPTY_GEOJSON,\n        });\n\n        this.map.addSource(\"marker-point\", {\n          type: \"geojson\",\n          data: MARKER,\n        });\n        const INSERTION_POINT = \"track casing\";\n\n        this.map.addLayer(\n          {\n            id: \"routeline-bg\",\n            source: \"route\",\n            type: \"line\",\n            layout: {\n              \"line-cap\": \"round\",\n              \"line-join\": \"round\",\n            },\n            paint: {\n              \"line-color\": [\n                \"case\",\n                [\"==\", [\"get\", \"mode\"], \"bus\"],\n                \"#592556\",\n                [\"==\", [\"get\", \"mode\"], \"metro\"],\n                \"#23388f\",\n                [\"==\", [\"get\", \"mode\"], \"foot\"],\n                \"#1c381b\",\n                \"black\",\n              ],\n              \"line-width\": 7,\n            },\n          },\n          INSERTION_POINT\n        );\n\n        this.map.addLayer(\n          {\n            id: \"routeline-nonfoot\",\n            source: \"route\",\n            type: \"line\",\n            filter: [\"!=\", [\"get\", \"mode\"], \"foot\"],\n            layout: {\n              \"line-cap\": \"round\",\n              \"line-join\": \"round\",\n            },\n            paint: {\n              \"line-color\": [\n                \"case\",\n                [\"==\", [\"get\", \"mode\"], \"bus\"],\n                \"#ba45b6\",\n                [\"==\", [\"get\", \"mode\"], \"metro\"],\n                \"#3388ff\",\n                [\"==\", [\"get\", \"mode\"], \"foot\"],\n                \"#5cb83b\",\n                \"black\",\n              ],\n              \"line-width\": 4,\n            },\n          },\n          INSERTION_POINT\n        );\n\n        this.map.addLayer(\n          {\n            id: \"routeline-foot\",\n            source: \"route\",\n            type: \"line\",\n            filter: [\"==\", [\"get\", \"mode\"], \"foot\"],\n            layout: {\n              \"line-cap\": \"round\",\n              \"line-join\": \"round\",\n            },\n            paint: {\n              \"line-color\": [\n                \"case\",\n                [\"==\", [\"get\", \"mode\"], \"bus\"],\n                \"#ba45b6\",\n                [\"==\", [\"get\", \"mode\"], \"metro\"],\n                \"#3388ff\",\n                [\"==\", [\"get\", \"mode\"], \"foot\"],\n                \"#5cb83b\",\n                \"black\",\n              ],\n              \"line-width\": 4,\n            },\n          },\n          INSERTION_POINT\n        );\n\n        this.map.addLayer(\n          {\n            id: \"marker\",\n            source: \"marker-point\",\n            type: \"circle\",\n            paint: {\n              \"circle-opacity\": 1,\n              \"circle-color\": \"white\",\n              \"circle-pitch-alignment\": \"map\",\n              \"circle-radius\": 7,\n              \"circle-stroke-width\": 3,\n              \"circle-stroke-color\": \"#5cb83b\",\n            },\n          },\n          INSERTION_POINT\n        );\n\n        this.map.addLayer(\n          {\n            id: \"mile-markers\",\n            source: \"mile-markers\",\n            type: \"symbol\",\n            layout: {\n              \"icon-image\": \"pin\",\n              \"icon-offset\": [0, -22],\n              \"icon-size\": 0.4,\n              \"icon-text-fit\": \"width\",\n              \"icon-text-fit-padding\": [0, 28, 0, 28],\n              \"text-field\": \"{distance}\",\n              \"text-font\": [\"Open Sans Semibold\", \"Arial Unicode MS Bold\"],\n              \"text-offset\": [0, -1.2],\n            },\n            paint: {\n              \"text-opacity\": 0.0,\n              \"icon-opacity\": 0.0,\n              \"text-color\": \"white\",\n              \"text-halo-color\": \"rgba(0,0,0,0.7)\",\n              \"text-halo-width\": 0.75,\n              \"text-halo-blur\": 0.5,\n            },\n          },\n          INSERTION_POINT\n        );\n\n        onload && onload();\n      });\n    });\n  }\n\n  setMarkerColor(color) {\n    this.map.setPaintProperty(\"marker\", \"circle-stroke-color\", color);\n  }\n\n  setMileMarkerOpacity(opacity) {\n    this.map.setPaintProperty(\"mile-markers\", \"text-opacity\", opacity);\n    this.map.setPaintProperty(\"mile-markers\", \"icon-opacity\", opacity);\n  }\n\n  setMileMarkers(geojson) {\n    this.map.getSource(\"mile-markers\").setData(geojson || EMPTY_GEOJSON);\n  }\n\n  setGlobalPadding(padding) {\n    this.map.easeTo({ padding, duration: 0 });\n  }\n\n  setRouteData(geojson) {\n    this.map.getSource(\"route\").setData(geojson || EMPTY_GEOJSON);\n  }\n\n  setCenter(position) {\n    this.map.setCenter(position);\n  }\n\n  setMarkerPosition(position) {\n    const markerLayer = map.getLayer(\"marker\");\n    if (!markerLayer) return;\n\n    const markerSource = map.getSource(\"marker-point\");\n    if (!markerSource) return;\n\n    if (!position) {\n      this.map.setPaintProperty(\"marker\", \"circle-opacity\", 0);\n    }\n    this.map.setPaintProperty(\"marker\", \"circle-opacity\", 1);\n    markerSource.setData(position ? point(position) : EMPTY_GEOJSON);\n  }\n\n  setTerrain(exaggeration, forceTerrain) {\n    const curTerrain = this.map.getTerrain();\n\n    if (exaggeration || forceTerrain) {\n      if (!curTerrain) {\n        this.map.setTerrain({ source: \"mapbox-dem\", exaggeration });\n      } else if (exaggeration !== curTerrain.exaggeration) {\n        this.map.setTerrain({\n          source: \"mapbox-dem\",\n          exaggeration,\n          \"exaggeration-transition\": { duration: 1000 },\n        });\n      }\n    } else if (curTerrain) {\n      this.map.setTerrain(null);\n    }\n  }\n\n  setSimplifiedMode(isSimplified) {\n    this.map.setLayoutProperty(\n      \"mile-markers\",\n      \"visibility\",\n      isSimplified ? \"none\" : \"visible\"\n    );\n\n    for (const layer of HOME_FADE_TEXT_LAYERS) {\n      this.map.setPaintProperty(layer, \"text-opacity\", isSimplified ? 0 : 1);\n      this.map.setPaintProperty(layer, \"icon-opacity\", isSimplified ? 0 : 1);\n    }\n  }\n}\n\nexport default MapController;\n","class Raf {\n  constructor (onframe) {\n    this.onframe = onframe;\n    this.raf = null;\n    this.tPrev = null;\n  }\n\n  start () {\n    const onframe = (t) => {\n      const dt = this.tPrev === null ? 0 : t - this.tPrev;\n      this.tPrev = t;\n\n      this.onframe(t, dt);\n\n      this.raf = requestAnimationFrame(onframe);\n    }\n    this.raf = requestAnimationFrame(onframe);\n  }\n\n  stop () {\n    if (this.raf) {\n      cancelAnimationFrame(this.raf);\n      this.raf = null;\n      this.tPrev = null;\n    }\n  }\n}\n\nexport default Raf;\n","export default function lerp (a, b, x) {\n  return x * b + (1.0 - x) * a;\n}\n","import lerp from './lerp.js';\n\nclass Smoother {\n  constructor (timescale) {\n    this.tol = 1e-10;\n    this.value = null;\n    this.target = null;\n    this.time = null;\n    this.timescale = timescale;\n    this.changedc = false;\n  }\n\n  setTarget (value) {\n    this.target = value;\n    this.changed = true;\n    if (this.value === null) {\n      this.value = this.target;\n    }\n  }\n\n  tick (dt) {\n    const oldValue = this.value;\n    const decay = Math.exp(-dt * Math.LN2 / this.timescale);\n    this.value = lerp(this.target, this.value, decay);\n    this.changed = Math.abs(oldValue - this.value) > this.tol;\n\n  }\n\n  getValue () {\n    if (this.value === null) {\n      throw new Error('invalid read of uninitialized smoother');\n    }\n    return [this.value, this.changed];\n  }\n\n  clear () {\n    this.value = null;\n    this.target = null;\n    this.time = null;\n    this.changed = true;\n  }\n}\n\nexport default Smoother;\n","const kmToMiles = (km) => km / 1.609;\n//const milesToKm = mi => mi * 1.609;\n\nclass ElevationPlot {\n  constructor() {\n    const el = document.createElement(\"div\");\n    el.setAttribute(\"id\", \"elevation-plot\");\n    document.body.appendChild(el);\n\n    const marker = (this.marker = document.createElement(\"div\"));\n    marker.classList.add(\"elevation-marker\");\n    el.appendChild(marker);\n\n    this.margin = { top: 5, right: 15, bottom: 17, left: 40 };\n\n    this.svg = d3.select(el).append(\"svg\");\n    this.container = this.svg.append(\"g\");\n\n    this.container.append(\"g\").attr(\"class\", \"x-axis axis\");\n    this.container.append(\"g\").attr(\"class\", \"y-axis axis\");\n    this.container.append(\"g\").attr(\"class\", \"grid x-grid\");\n    this.container.append(\"g\").attr(\"class\", \"grid y-grid\");\n    this.container.append(\"path\").attr(\"class\", \"elevation-fill\");\n    this.container.append(\"path\").attr(\"class\", \"elevation\");\n\n    this.data = null;\n\n    window.addEventListener(\"resize\", () => this.draw());\n  }\n\n  getIndex(dist) {\n    if (!this.data) return -1;\n    let lo = 0;\n    let hi = this.data.length - 1;\n    let middle;\n    while (lo <= hi) {\n      middle = Math.floor((lo + hi) / 2);\n      if (this.data[middle].distance === dist) {\n        return middle;\n      } else if (this.data[middle].distance < dist) {\n        lo = middle + 1;\n      } else {\n        hi = middle - 1;\n      }\n    }\n    return middle;\n  }\n\n  setProgress(progress) {\n    if (!this.data || !this.x || !this.y) return;\n    if (arguments.length) this._progress = progress;\n    const dist = this.data[this.data.length - 1].distance;\n    const index = this.getIndex(dist * this._progress);\n    const elevation = this.data[index].elevation;\n    window.elplot = this;\n\n    const x = this.x(kmToMiles(dist * this._progress)) + this.margin.left;\n    const y = this.y(elevation) + this.margin.top;\n    this.marker.style.transform = `translate(${x}px,${y}px)`;\n  }\n\n  draw() {\n    if (!this.data) return;\n\n    this.width = Math.min(\n      520 - this.margin.left - this.margin.right,\n      Math.max(\n        Math.min(window.innerWidth, 540),\n        window.innerWidth - 520 - this.margin.left - this.margin.right\n      )\n    );\n    this.width = Math.min(\n      this.width,\n      window.innerWidth - this.margin.left - this.margin.right\n    );\n    this.height = window.innerWidth <= 640 ? 60 : 100;\n\n    this.svg\n      .attr(\"width\", this.width + this.margin.left + this.margin.right)\n      .attr(\"height\", this.height + this.margin.top + this.margin.bottom);\n\n    this.container.attr(\n      \"transform\",\n      \"translate(\" + this.margin.left + \",\" + this.margin.top + \")\"\n    );\n\n    const x = (this.x = d3\n      .scaleLinear()\n      .domain([0, kmToMiles(this.data[this.data.length - 1].distance)])\n      .range([0, this.width]));\n\n    const y = (this.y = d3\n      .scaleLinear()\n      .domain([this.minElevation, this.maxElevation])\n      .range([this.height, 0]));\n\n    const xAxis = d3.axisBottom(x).ticks(10);\n    const yAxis = d3.axisLeft(y).ticks(5);\n\n    this.container\n      .select(\".x-axis\")\n      .attr(\"transform\", \"translate(0,\" + this.height + \")\")\n      .call(xAxis);\n    this.container.select(\".y-axis\").call(yAxis);\n\n    //const xGrid = xAxis.tickSize(-this.height).tickFormat(\"\");\n    const yGrid = yAxis.tickSize(-this.width).tickFormat(\"\");\n\n    /*this.container\n      .select(\".x-grid\")\n      .attr(\"transform\", \"translate(0,\" + this.height + \")\")\n      .call(xGrid);*/\n\n    this.container.select(\".y-grid\").call(yGrid);\n\n    this.container\n      .select(\".elevation\")\n      .datum(this.data)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"#5cb83b\")\n      .attr(\"stroke-width\", 3)\n      .attr(\n        \"d\",\n        d3\n          .line()\n          .x(function (d) {\n            return kmToMiles(x(d.distance));\n          })\n          .y(function (d) {\n            return y(d.elevation);\n          })\n      );\n\n    const fillData = this.data.slice();\n    const rhs = { ...fillData[fillData.length - 1] };\n    const lhs = { ...fillData[0] };\n    rhs.elevation = y.invert(this.height);\n    lhs.elevation = y.invert(this.height);\n    fillData.push(rhs, lhs);\n\n    this.container\n      .select(\".elevation-fill\")\n      .datum(fillData)\n      .attr(\"fill\", \"#31814126\")\n      .attr(\"stroke\", \"none\")\n      .attr(\n        \"d\",\n        d3\n          .line()\n          .x(function (d) {\n            return kmToMiles(x(d.distance));\n          })\n          .y(function (d) {\n            return y(d.elevation);\n          })\n      );\n  }\n\n  setProfile(profile) {\n    if (profile) this.data = profile;\n    if (!profile) return;\n\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < this.data.length; i++) {\n      min = Math.min(min, this.data[i].elevation);\n      max = Math.max(max, this.data[i].elevation);\n    }\n    //const avg = (max + min) * 0.5;\n    const rad = (max - min) * 0.5;\n    min -= rad * 0.1;\n    max += rad * 0.1;\n    this.minElevation = min;\n    this.maxElevation = max;\n\n    this.draw();\n  }\n}\n\nexport default ElevationPlot;\n","import MapController from \"./map-controller.js\";\nimport Raf from \"../util/raf.js\";\nimport Smoother from \"../util/smoother.js\";\nimport Route from \"./route.js\";\nimport ElevationPlot from \"./elevation-plot.js\";\n\nconst MODE_COLORS = {\n  bus: \"#ba45b6\",\n  foot: \"#5cb83b\",\n  metro: \"#3388ff\",\n};\n\nclass PageController {\n  constructor() {\n    if (typeof window !== \"undefined\") {\n      window.pageController = this;\n    }\n    this.map = null;\n\n    this._onload = [];\n    this.loaded = false;\n\n    this.route = null;\n    this.followProgress = new Smoother(150);\n    this.dirty = false;\n    this.needsPaddingUpdate = true;\n    this.featureMode = null;\n\n    this.followTimer = new Raf(this.step.bind(this));\n  }\n\n  initializeMap(container, bounds, callback) {\n    this.elevationPlot = new ElevationPlot();\n\n    this.map = new MapController(\n      container,\n      bounds,\n      this.computeGlobalPadding(),\n      () => {\n        this.loaded = true;\n        while (this._onload.length) {\n          this._onload.pop()(this.map);\n        }\n      }\n    );\n  }\n\n  ready() {\n    if (this.loaded) return Promise.resolve(this.map);\n    return new Promise((resolve) => {\n      this._onload.push(resolve);\n    });\n  }\n\n  setRoute(geojson, bounds, isInitialLoad) {\n    this.dirty = true;\n    this.route = new Route(geojson);\n    this.ready().then(() => {\n      this.map.setRouteData(this.route.getGeojson());\n      this.map.setMileMarkers(this.route.getMileMarkers());\n      this.map.map.fitBounds(this.route.getBbox({ mode: \"foot\" }), {\n        duration: isInitialLoad ? 0 : 2000,\n      });\n      this.elevationPlot.setProfile(this.route.getElevationProfile());\n    });\n  }\n\n  clearRoute() {\n    this.route = null;\n    this.followProgress.clear();\n    this.map.setMileMarkers(null);\n    this.ready().then(() => {\n      this.map.setRouteData(null);\n    });\n  }\n\n  stop() {\n    this.followTimer.stop();\n  }\n\n  step(t, dt) {\n    this.followProgress.tick(dt);\n    const [progress, changed] = this.followProgress.getValue();\n\n    if (changed || this.dirty) {\n      this.dirty = false;\n      switch (this.mode) {\n        case \"follow\":\n          if (this.route) {\n            this.applyFollowProgress(progress, this.followProgress.target);\n\n            this.map.camera.tick(t);\n          }\n          break;\n      }\n    }\n  }\n\n  setFeatureMode(mode) {\n    if (!mode) {\n      document.body.removeAttribute(\"data-feature-mode\");\n    }\n\n    if (mode === this.featureMode) return;\n\n    this.map.setMarkerColor(MODE_COLORS[mode || \"metro\"]);\n\n    if (mode) {\n      document.body.setAttribute(\"data-feature-mode\", mode);\n    }\n\n    switch (mode) {\n      case \"foot\":\n        this.map.setMileMarkerOpacity(1);\n        break;\n      default:\n        this.map.setMileMarkerOpacity(0);\n    }\n    this.featureMode = mode;\n  }\n\n  applyFollowProgress(progress, targetProgress, forcePosition) {\n    if (!this.route) return;\n    const [uneasedPosition] = this.route.evaluate(targetProgress);\n    const [easedPosition, feature] = this.route.evaluate(progress);\n\n    this.applyGlobalPadding();\n    this.map.setTerrain(feature.properties.mode === \"foot\" ? 1.3 : 0, true);\n\n    this.map.camera.targetCenter = uneasedPosition;\n    this.map.camera.targetPitch = 40;\n\n    this.setFeatureMode(feature.properties.mode);\n    if (feature.properties.mode === \"foot\") {\n      this.map.camera.targetDistance = 2500;\n    } else if (feature.properties.mode === \"bus\") {\n      this.map.camera.targetDistance = 7000;\n    } else {\n      this.map.camera.targetDistance = 13000;\n    }\n\n    this.map.setMarkerPosition(easedPosition);\n\n    if (feature.properties.mode === \"foot\") {\n      this.elevationPlot.setProgress(progress % 1);\n    }\n  }\n\n  computeGlobalPadding() {\n    const isHero = !this.mode || this.mode === \"bound\";\n    const padding = { top: 60, right: 60, bottom: 60, left: 60 };\n\n    if (isHero) {\n      padding.bottom = window.innerHeight * 0.3 + 60;\n    } else {\n      padding.left = Math.max(60, Math.min(520 + 60, window.innerWidth - 520));\n    }\n    return padding;\n  }\n\n  applyGlobalPadding() {\n    if (!this.needsPaddingUpdate) return;\n    this.needsPaddingUpdate = false;\n    this.map.setGlobalPadding(this.computeGlobalPadding());\n  }\n\n  // A pseudo-state-machine, but without cleanly defined transitions :shrug:\n  setProgress(mode, progress) {\n    const isModeChange = mode !== this.mode;\n    this.mode = mode;\n    if (isModeChange) {\n      this.needsPaddingUpdate = true;\n    }\n    switch (this.mode) {\n      case \"bound\":\n        this.setFeatureMode(null);\n        this.applyGlobalPadding();\n        this.map.setTerrain(null);\n        this.map.camera.clear();\n        this.followProgress.clear();\n        if (isModeChange) {\n          this.followTimer.stop();\n          this.map.setMarkerPosition(null);\n          if (this.route) {\n            this.map.map.fitBounds(this.route.getBbox({ mode: \"foot\" }), {\n              duration: 1000,\n            });\n            this.map.map.once(\"idle\", () => this.map.map.easeTo({ pitch: 0 }));\n          }\n        }\n        break;\n      case \"follow\":\n        if (isModeChange) {\n          this.followTimer.start();\n        }\n\n        this.followProgress.setTarget(progress);\n\n        break;\n      default:\n        throw new Error(`invalid route mode: ${mode}`);\n    }\n  }\n\n  setSimplifiedMode(isSimplified) {\n    this.map.setSimplifiedMode(isSimplified);\n  }\n}\n\nexport default PageController;\n","import { createContext } from 'preact';\nimport PageController from './page-controller.js';\n\nexport default createContext(new PageController());\n","import { html } from 'htm/preact';\nimport { useRef, useState, useEffect, useContext } from 'preact/hooks';\nimport pageControllerContext from '../data/page-controller-context.js';\n\nexport default function MapView (props) {\n  const pageController = useContext(pageControllerContext);\n  const mapEl = useRef(null);\n\n  useEffect(() => {\n    pageController.initializeMap(mapEl.current, props.initialBounds);//, !props.isHome);\n  }, []);\n\n  return html`<div ref=${mapEl} class=\"mbxmap\"/>`\n}\n","import { html } from \"htm/preact\";\nimport { useRef, useEffect, useContext } from \"preact/hooks\";\nimport pageControllerContext from \"../data/page-controller-context.js\";\nimport Ratings from \"./ratings.js\";\nimport quadInOut from \"eases/quad-in-out.js\";\nimport lerp from \"../util/lerp.js\";\n\nconst EXTERNAL_URL_REGEX = /^http/;\nlet initialLoad = true;\n\nconst SIMPLIFY_LAYERS = [\"\", \"introduction/\"];\n\nfunction Article({ page, setPath }) {\n  const contentContainer = useRef(null);\n  const pageController = useContext(pageControllerContext);\n\n  const isHome = page.metadata.path === \"\";\n  const isFront = page.metadata.isFront;\n\n  useEffect(async () => {\n    await pageController.ready();\n\n    pageController.setSimplifiedMode(\n      SIMPLIFY_LAYERS.indexOf(page.metadata.path) !== -1\n    );\n\n    const routePath = page.metadata.routeurl;\n    if (routePath) {\n      fetch(routePath)\n        .then((response) => {\n          if (!response.ok) throw new Error(\"failed to load route\");\n          return response.json();\n        })\n        .then((geojson) => {\n          pageController.setRoute(geojson, page.metadata.bounds, initialLoad);\n          window.dispatchEvent(new CustomEvent(\"scroll\"));\n          initialLoad = false;\n        });\n    } else {\n      pageController.clearRoute(initialLoad ? null : page.metadata.bounds);\n      initialLoad = false;\n    }\n  }, []);\n\n  function navigate(event) {\n    const a =\n      event.target.tagName === \"A\" ? event.target : event.target.closest(\"a\");\n    if (!a) return;\n    let href = a.getAttribute(\"href\");\n    if (EXTERNAL_URL_REGEX.test(href)) return;\n\n    if (!href.endsWith(\"/\")) href += \"/\";\n    if (href === \"/\") href = \"\";\n\n    event.stopPropagation();\n    event.preventDefault();\n\n    setPath(href);\n  }\n\n  useEffect(() => {\n    if (!contentContainer.current) return;\n    contentContainer.current.addEventListener(\"click\", navigate);\n    const { current: el } = contentContainer;\n    const controlEls = el.querySelectorAll(\"[data-route-mode]\");\n\n    function computePosition(event) {\n      const offset = window.innerHeight * 0.15;\n      const stops = [];\n      for (const c of controlEls)\n        stops.push(c.getBoundingClientRect().y - offset);\n      let i;\n      for (i = 0; i < stops.length && stops[i] < 0; i++);\n      i = Math.max(i - 1, 0);\n      const from = controlEls[Math.max(0, i)];\n      const to = controlEls[Math.min(i + 1, controlEls.length - 1)];\n      let position = Math.max(\n        0,\n        Math.min(1, -stops[i] / (stops[i + 1] - stops[i]))\n      );\n      //position = Math.floor(position) + quadInOut(position);\n\n      const fromProgress = from\n        ? parseFloat(from.getAttribute(\"data-route-progress\"))\n        : 0;\n      let toProgress = to\n        ? parseFloat(to.getAttribute(\"data-route-progress\"))\n        : fromProgress;\n      if (isNaN(toProgress)) toProgress = fromProgress;\n      const progress = lerp(fromProgress, toProgress, position);\n\n      const mode = from ? from.getAttribute(\"data-route-mode\") : \"bound\";\n\n      pageController.setProgress(mode, progress);\n    }\n\n    const onResize = (event) => computePosition(event, true);\n\n    window.addEventListener(\"scroll\", computePosition);\n    window.addEventListener(\"resize\", onResize);\n    onResize(null, true);\n\n    return () => {\n      contentContainer.current.removeEventListener(\"click\", navigate);\n      window.removeEventListener(\"scroll\", computePosition);\n      window.removeEventListener(\"resize\", onResize);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (!contentContainer.current) return;\n    let commentDst = contentContainer.current.querySelector(\".giscus-comments\");\n    if (!commentDst) {\n      commentDst = contentContainer.current.querySelector(\n        \".articleContent--conclusion\"\n      );\n    }\n\n    if (commentDst) {\n      const giscusTag = document.createElement(\"script\");\n      giscusTag.setAttribute(\"src\", \"https://giscus.app/client.js\");\n      giscusTag.setAttribute(\"data-repo\", \"rreusser/trains-and-trails\");\n      giscusTag.setAttribute(\"data-repo\", \"rreusser/trains-and-trails\");\n      giscusTag.setAttribute(\n        \"data-repo-id\",\n        \"MDEwOlJlcG9zaXRvcnk0MDUyODUwMjY=\"\n      );\n      giscusTag.setAttribute(\"data-category\", \"Announcements\");\n      giscusTag.setAttribute(\"data-category-id\", \"DIC_kwDOGCgoos4CnXtQ\");\n      giscusTag.setAttribute(\"data-mapping\", \"pathname\");\n      giscusTag.setAttribute(\"data-strict\", \"0\");\n      giscusTag.setAttribute(\"data-reactions-enabled\", \"1\");\n      giscusTag.setAttribute(\"data-emit-metadata\", \"0\");\n      giscusTag.setAttribute(\"data-input-position\", \"bottom\");\n      giscusTag.setAttribute(\"data-theme\", \"light\");\n      giscusTag.setAttribute(\"data-lang\", \"en\");\n      giscusTag.setAttribute(\"crossorigin\", \"anonymous\");\n      giscusTag.setAttribute(\"async\", \"async\");\n\n      requestAnimationFrame(() => commentDst.appendChild(giscusTag));\n    }\n  }, []);\n\n  return html` <div\n    class=\"articleContainer ${isFront ? \"is-front\" : \"\"} ${isHome\n      ? \"is-home\"\n      : \"\"}\"\n  >\n    <div class=\"articleHeader\">\n      ${isHome\n        ? \"\"\n        : html`<a href=\"\" onClick=${(event) => navigate(event, \"\")}>← Back</a>`}\n      <h1>${page.metadata.title}</h1>\n      <div class=\"article_date\">${page.metadata.date}</div>\n    </div>\n    <div class=\"articleBody\">\n      ${\"\" /*page.metadata.ratings ? html`<${Ratings}/>` : null*/}\n      <div\n        ref=${contentContainer}\n        dangerouslySetInnerHTML=${{ __html: page.articleHTML }}\n      />\n    </div>\n  </div>`;\n}\n\nexport default Article;\n","import MbxMap from \"./map.js\";\nimport { html } from \"htm/preact\";\nimport Article from \"./article.js\";\nimport Overlay from \"./overlay.js\";\nimport { useState, useEffect, useContext } from \"preact/hooks\";\nimport pageControllerContext from \"../data/page-controller-context.js\";\n\nconst pageCache = new Map();\nfunction getPage(path) {\n  if (pageCache.has(path)) return Promise.resolve(pageCache.get(path));\n  return fetch(path)\n    .then((response) => {\n      if (!response.ok) throw new Error(\"404d!\");\n      return response.json();\n    })\n    .then((page) => {\n      pageCache.set(path, page);\n      return page;\n    });\n}\n\nfunction App(props) {\n  const [path, setPath] = useState(props.page.metadata.path);\n  const [page, setPage] = useState(props.page);\n  const [fetching, setFetching] = useState(false);\n  const pageController = useContext(pageControllerContext);\n\n  useEffect(() => {\n    const search = new URLSearchParams(window.location.search);\n    const searchString = search.toString();\n    const pagePath = searchString\n      ? `${page.baseURL}${path}?${searchString}`.replace(/\\/\\//g, \"/\")\n      : `${page.baseURL}${path}`.replace(/\\/\\//g, \"/\");\n\n    history.pushState({ page, path }, \"\", pagePath);\n    function onChange(event) {\n      setPath(event.state.path);\n      setPage(event.state.page);\n      pageController.stop();\n    }\n    window.addEventListener(\"popstate\", onChange);\n  }, []);\n\n  useEffect(() => {\n    // Truncate search params when computing navigation\n    const pathWithoutSearch = (path || \"\").replace(/\\?.*$/, \"\");\n    if (pathWithoutSearch === page.metadata.path) return;\n    if (fetching) return;\n\n    // Persist search params (containing giscus session) when navigating\n    const search = new URLSearchParams(window.location.search);\n    const contentPath = window.manifest[pathWithoutSearch];\n    const dstPath = search.toString() ? `${path}?${search.toString()}` : path;\n\n    setFetching(true);\n    history.pushState({ dstPath, page: null }, \"\", dstPath);\n    getPage(contentPath)\n      .then((page) => {\n        setPage(page);\n        history.replaceState({ dstPath, page }, \"\", dstPath);\n      })\n      .then(\n        () => setFetching(false),\n        () => setFetching(false)\n      );\n  });\n\n  function navigate(...args) {\n    setPath(...args);\n    window.scrollTo(0, 0);\n  }\n\n  return html`\n    <${MbxMap}\n      initialBounds=${page.metadata.bounds}\n      isHome=${page.metadata.path === \"/\"}\n    />\n    <div class=\"left-spacer\" />\n    <${Article}\n      key=${page.metadata.path || \"/\"}\n      page=${page}\n      setPath=${navigate}\n    />\n    <div class=\"right-spacer\" />\n  `;\n}\n\nexport default App;\n","import App from './components/app.js';\nimport { render, h } from 'preact';\n\nrender(\n  h(App, {page: window.page}),\n  document.getElementById('root')\n);\n"],"names":["EMPTY_OBJ","EMPTY_ARR","IS_NON_DIMENSIONAL","n","t","s","r","e","u","h","length","p","a","Object","assign","apply","push","Map","currentIndex","currentComponent","prevRaf","m","get","this","set","replace","l","arguments","bind","currentHook","afterPaintEffects","oldBeforeDiff","options","__b","oldBeforeRender","__r","oldAfterDiff","diffed","oldCommit","__c","oldBeforeUnmount","unmount","getHookState","index","type","hooks","__H","__","__h","useState","initialState","reducer","init","hookState","_reducer","invokeOrReturn","action","nextValue","setState","useReducer","useEffect","callback","args","state","argsChanged","useRef","initialValue","factory","useMemo","current","useContext","context","provider","sub","props","value","flushAfterPaintEffects","component","shift","forEach","invokeCleanup","invokeEffect","vnode","c","requestAnimationFrame","raf","done","clearTimeout","timeout","HAS_RAF","cancelAnimationFrame","setTimeout","commitQueue","some","filter","cb","hasErrored","hook","comp","cleanup","undefined","oldArgs","newArgs","arg","f","earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","feature","geom","properties","feat","id","bbox","geometry","point","coordinates","Error","Array","isArray","isNumber","lineString","featureCollection","features","fc","radiansToDegrees","Math","PI","degreesToRadians","num","isNaN","coordEach","geojson","excludeWrapCoord","j","k","stopG","coords","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","i","g","featureProperties","featureBBox","featureId","segmentEach","coordinate","flattenEach","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","result","Infinity","coord","getCoord","getCoords","distance","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","pow","sin","cos","units","factor","radiansToLength","atan2","sqrt","previousValue","started","segmentReduce","segment","bearing","start","end","bear","calculateFinalBearing","lon1","lon2","b","destination","origin","longitude1","latitude1","bearingRad","lengthToRadians","latitude2","asin","exports","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","descriptor","enumerable","configurable","writable","defineProperty","key","_createClass","protoProps","staticProps","prototype","length_1$1","length$1","x","y","z","normalize_1$1","normalize$1","out","len","cross_1","cross","ax","ay","az","bx","by","bz","normalize_1","normalize","length_1","dot_1","dot","CameraController","map","_ref","_ref$distance","_ref$pitch","pitch","_ref$bearing","MercatorCoordinate","getFreeCameraOptions","position","constructor","_distanceTarget","_pitchTarget","_bearingTarget","_centerTarget","center","fromLngLat","transform","_center","_previousCenter","_previousTime","NaN","_previousLookAtTime","_errorIntegral","globalStrength","Kp_pan","Ki_pan","Kd_pan","Kp_pitch","Kp_dist","Kp_bearing","_follow","_hadTerrain","elevation","queryTerrainElevation","P","I","D","max","min","toMeters","meterInMercatorCoordinateUnits","cam","hasTerrain","getTerrain","_cloneCoord","dist","toLngLat","theta","phi","lookAtPoint","setFreeCameraOptions","dt","el","mPanErr","targetErrorMeters","sky","vcam","e0cam","e1cam","e2cam","camDist","camDistForce","camPitch","acos","pitchForce","bearingTarget","curBearing","bearingForce","lx","ly","lz","pani","panp","pand","distp","pitchp","bearingp","abs","dlookdt","_dt","panx","pany","panz","cleanLine","line","points","equals","newPoints","secondToLast","newPointsLength","prevAddedPoint","isPointOnLineSegment","splice","pt1","pt2","startX","startY","endX","endY","dxl","dyl","clone","cloneFeature","cloned","keys","cloneFeatureCollection","cloneGeometry","cloneProperties","_typeof","item","deepSlice","slice","getSqSegDist","p1","p2","dx","dy","simplifyDPStep","first","last","sqTolerance","simplified","maxSqDist","sqDist","simplifyDouglasPeucker","simplify","tolerance","highestQuality","prevPoint","simplifyRadialDist","simplify$1","input","highQuality","mutate","_name","getType","newCoords","polygons","polyPoints","ring","existing","join","hasOwnProperty","call","cleanCoords","simplifyLine","lines","simplifyPolygon","rings","simplifyGeom","pts","simpleRing","checkValidity","EMPTY_GEOJSON","metersToFeet","Route","elevationProfiles","bboxes","all","foot","mode","computeElevationProfile","_lengthCache","profile","els","els2","getFootFeatureIndex","_ref2","_ref2$mode","floor","featureProgress","pos","travelled","overshot","direction","measureDistance","along","featureLength","_step","markers","_iterator","_createForOfIteratorHelper","_feature$properties","_feature$properties$m","_feature$properties$m2","_toConsumableArray","mi","err","window","mapboxgl","accessToken","HOME_FADE_TEXT_LAYERS","MARKER","MapController","container","bounds","padding","onload","_this","style","scrollZoom","boxZoom","dragRotate","dragPan","keyboard","doubleClickZoom","touchZoomRotate","interactive","logoPosition","fitBoundsOptions","camera","on","fov","loadImage","error","image","addImage","addSource","url","tileSize","maxzoom","storedHillshadeResolution","localStorage","getItem","useCustomHillshade","getSource","addLayer","source","paint","data","INSERTION_POINT","layout","color","setPaintProperty","opacity","setData","easeTo","duration","setCenter","getLayer","markerSource","exaggeration","forceTerrain","curTerrain","setTerrain","isSimplified","setLayoutProperty","layer","Raf","onframe","tPrev","lerp","Smoother","timescale","tol","time","changedc","changed","oldValue","decay","exp","LN2","kmToMiles","km","ElevationPlot","document","createElement","setAttribute","body","appendChild","marker","classList","add","margin","top","right","bottom","left","svg","d3","select","append","attr","addEventListener","draw","middle","lo","hi","progress","_progress","getIndex","elplot","width","innerWidth","height","scaleLinear","domain","range","minElevation","maxElevation","xAxis","axisBottom","ticks","yAxis","axisLeft","yGrid","tickSize","tickFormat","datum","d","fillData","rhs","lhs","invert","rad","MODE_COLORS","bus","metro","PageController","pageController","_onload","loaded","route","followProgress","dirty","needsPaddingUpdate","featureMode","followTimer","step","elevationPlot","computeGlobalPadding","pop","_this2","Promise","resolve","isInitialLoad","_this3","ready","then","setRouteData","getGeojson","setMileMarkers","getMileMarkers","fitBounds","getBbox","setProfile","getElevationProfile","_this4","clear","tick","_this$followProgress$2","_slicedToArray","getValue","applyFollowProgress","removeAttribute","setMarkerColor","setMileMarkerOpacity","targetProgress","forcePosition","uneasedPosition","evaluate","_this$route$evaluate4","easedPosition","applyGlobalPadding","targetCenter","targetPitch","setFeatureMode","targetDistance","setMarkerPosition","setProgress","innerHeight","setGlobalPadding","_this5","isModeChange","once","setTarget","setSimplifiedMode","pageControllerContext","createContext","MapView","mapEl","initializeMap","initialBounds","html","EXTERNAL_URL_REGEX","initialLoad","SIMPLIFY_LAYERS","Article","page","setPath","contentContainer","isHome","metadata","path","isFront","navigate","event","tagName","closest","href","getAttribute","test","endsWith","stopPropagation","preventDefault","_asyncToGenerator","_regeneratorRuntime","mark","_callee","routePath","wrap","_context","prev","next","indexOf","routeurl","fetch","response","ok","json","setRoute","dispatchEvent","CustomEvent","clearRoute","controlEls","querySelectorAll","onResize","computePosition","removeEventListener","offset","stops","getBoundingClientRect","fromProgress","parseFloat","toProgress","commentDst","querySelector","giscusTag","_templateObject2","_taggedTemplateLiteral","title","date","__html","articleHTML","pageCache","render","_useState2","_useState4","setPage","_useState6","fetching","setFetching","searchString","URLSearchParams","location","search","toString","pagePath","baseURL","concat","history","pushState","pathWithoutSearch","contentPath","manifest","dstPath","has","getPage","replaceState","_templateObject","MbxMap","scrollTo","getElementById"],"mappings":"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"}